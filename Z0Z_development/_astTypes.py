import ast  # noqa: INP001

# For my reference, all ast classes by subclass:
type Ima_ast_boolop = ast.boolop | ast.And | ast.Or
type Ima_ast_cmpop = ast.cmpop | ast.Eq | ast.NotEq | ast.Lt | ast.LtE | ast.Gt | ast.GtE | ast.Is | ast.IsNot | ast.In | ast.NotIn
type Ima_ast_excepthandler = ast.excepthandler | ast.ExceptHandler
type Ima_ast_expr_context = ast.expr_context | ast.Load | ast.Store | ast.Del
type Ima_ast_expr = ast.expr | ast.Attribute | ast.Await | ast.BinOp | ast.BoolOp | ast.Call | ast.Compare | ast.Constant | ast.Dict | ast.DictComp | ast.FormattedValue | ast.GeneratorExp | ast.IfExp | ast.JoinedStr | ast.Lambda | ast.List | ast.ListComp | ast.Name | ast.NamedExpr | ast.Set | ast.SetComp | ast.Slice | ast.Starred | ast.Subscript | ast.Tuple | ast.UnaryOp | ast.Yield | ast.YieldFrom
type Ima_ast_mod = ast.mod | ast.Expression | ast.FunctionType | ast.Interactive | ast.Module
type Ima_ast_operator = ast.operator | ast.Add | ast.Sub | ast.Mult | ast.MatMult | ast.Div | ast.Mod | ast.Pow | ast.LShift | ast.RShift | ast.BitOr | ast.BitXor | ast.BitAnd | ast.FloorDiv
type Ima_ast_pattern = ast.pattern | ast.MatchAs | ast.MatchClass | ast.MatchMapping | ast.MatchOr | ast.MatchSequence | ast.MatchSingleton | ast.MatchStar | ast.MatchValue
type Ima_ast_stmt = ast.stmt | ast.AnnAssign | ast.Assert | ast.Assign | ast.AsyncFor | ast.AsyncFunctionDef | ast.AsyncWith | ast.AugAssign | ast.Break | ast.ClassDef | ast.Continue | ast.Delete | ast.Expr | ast.For | ast.FunctionDef | ast.Global | ast.If | ast.Import | ast.ImportFrom | ast.Match | ast.Nonlocal | ast.Pass | ast.Raise | ast.Return | ast.Try | ast.TryStar | ast.TypeAlias | ast.While | ast.With
type Ima_ast_type_ignore = ast.type_ignore | ast.TypeIgnore
type Ima_ast_type_param = ast.type_param | ast.ParamSpec | ast.TypeVar | ast.TypeVarTuple
type Ima_ast_unaryop = ast.unaryop | ast.Invert | ast.Not | ast.UAdd | ast.USub
type Ima_astAST = ast.AST | ast.alias | ast.arg | ast.arguments | ast.comprehension | ast.keyword | ast.match_case | ast.withitem

# NOTE Prototype of an old idea to subclass composable methods so that typing information
# can extend beyond the top level of the ast node.
# To cover all cases, quantity of necessary classes = sum of (for each class: for each attribute: attribute * number of valid types). If an attribute has type ast.expr, for example, then there are 27 valid types just for that attribute. There would be thousands of subclasses like ImaCallToName.
# class ImaCallToName(ast.Call):
# 	func: ast.Name

allIdentifiers=[
'Add',
'alias',
'And',
'AnnAssign',
'annotation',
'arg',
'args',
'argtypes',
'arguments',
'asname',
'Assert',
'Assign',
'AsyncFor',
'AsyncFunctionDef',
'AsyncWith',
'attr',
'Attribute',
'AugAssign',
'Await',
'bases',
'BinOp',
'BitAnd',
'BitOr',
'BitXor',
'body',
'boolop',
'BoolOp',
'bound',
'Break',
'Call',
'cases',
'cause',
'ClassDef',
'cls',
'cmpop',
'col_offset',
'comparators',
'Compare',
'comprehension',
'Constant',
'context_expr',
'Continue',
'conversion',
'ctx',
'decorator_list',
'default_value',
'defaults',
'Del',
'Delete',
'Dict',
'DictComp',
'Div',
'elt',
'elts',
'end_col_offset',
'end_lineno',
'Eq',
'exc',
'excepthandler',
'ExceptHandler',
'expr_context',
'expr',
'Expr',
'Expression',
'finalbody',
'FloorDiv',
'For',
'format_spec',
'FormattedValue',
'func',
'FunctionDef',
'FunctionType',
'GeneratorExp',
'generators',
'Global',
'Gt',
'GtE',
'guard',
'handlers',
'id',
'If',
'IfExp',
'ifs',
'Import',
'ImportFrom',
'In',
'Interactive',
'Invert',
'is_async',
'Is',
'IsNot',
'items',
'iter',
'JoinedStr',
'key',
'keys',
'keyword',
'keywords',
'kind',
'kw_defaults',
'kwarg',
'kwd_attrs',
'kwd_patterns',
'kwonlyargs',
'Lambda',
'left',
'level',
'lineno',
'List',
'ListComp',
'Load',
'lower',
'LShift',
'Lt',
'LtE',
'match_case',
'Match',
'MatchAs',
'MatchClass',
'MatchMapping',
'MatchOr',
'MatchSequence',
'MatchSingleton',
'MatchStar',
'MatchValue',
'MatMult',
'mod',
'Mod',
'Module',
'module',
'msg',
'Mult',
'Name',
'name',
'NamedExpr',
'names',
'Nonlocal',
'Not',
'NotEq',
'NotIn',
'op',
'operand',
'operator',
'ops',
'optional_vars',
'Or',
'orelse',
'ParamSpec',
'Pass',
'pattern',
'patterns',
'posonlyargs',
'Pow',
'Raise',
'rest',
'Return',
'returns',
'right',
'RShift',
'Set',
'SetComp',
'simple',
'Slice',
'slice',
'Starred',
'step',
'stmt',
'Store',
'Sub',
'subject',
'Subscript',
'tag',
'target',
'targets',
'test',
'Try',
'TryStar',
'Tuple',
'type_comment',
'type_ignore',
'type_ignores',
'type_param',
'type_params',
'type',
'TypeAlias',
'TypeIgnore',
'TypeVar',
'TypeVarTuple',
'UAdd',
'UnaryOp',
'unaryop',
'upper',
'USub',
'value',
'values',
'vararg',
'While',
'With',
'withitem',
'Yield',
'YieldFrom',
]

pythonKeywords = [
'and',
'as',
'assert',
'async',
'await',
'break',
'class',
'continue',
'def',
'del',
'elif',
'else',
'except',
'False',
'finally',
'for',
'from',
'global',
'if',
'import',
'in',
'is',
'lambda',
'None',
'nonlocal',
'not',
'or',
'pass',
'raise',
'return',
'True',
'try',
'while',
'with',
'yield',
]

pythonOperators = [
'+',
'-',
'*',
'**',
'/',
'//',
'%',
'@',
'<<',
'>>',
'&',
'|',
'^',
'~',
':=',
'<',
'>',
'<=',
'>=',
'==',
'!=',
]

pythonDelimiters = [
'(',
')',
'[',
']',
'{',
'}',
',',
':',
'!',
'.',
';',
'=',
'->',
'+=',
'-=',
'*=',
'/=',
'//=',
'%=',
'@=',
'&=',
'|=',
'^=',
'>>=',
'<<=',
'**=',
]
