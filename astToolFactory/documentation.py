"""A warehouse for docstrings added to manufactured ast tools."""
from astToolFactory._warehouse.diminutive2etymology import diminutive2etymology as diminutive2etymology
from astToolFactory._warehouse.map2PythonDelimiters import map2PythonDelimiters as map2PythonDelimiters
from astToolFactory._warehouse.map2PythonKeywords import map2PythonKeywords as map2PythonKeywords
from astToolFactory._warehouse.map2PythonOperators import map2PythonOperators as map2PythonOperators
from astToolkit import identifierDotAttribute, Make
from collections import defaultdict
from dataclasses import dataclass
from hunterMakesPy import raiseIfNone
from itertools import chain
from typing import TypedDict
import ast
import dataclasses
import itertools
import textwrap

# 31337 H4XÃ˜R

docstrings: dict[str, dict[str, ast.Expr]] = defaultdict(lambda: defaultdict(lambda: Make.Expr(Make.Constant(''))))

docstringWarning = Make.Expr(Make.Constant("""Automatically generated file, so changes may be overwritten."""))

class astClassData(TypedDict):
	"""Data about an AST class and its relationships."""

	identifierClass: str
	"""The class name, e.g., 'FunctionDef'."""
	identifierDotClass: identifierDotAttribute
	"""The fully qualified class identifier with backticks, e.g., '`ast.FunctionDef`'."""
	matchesClasses: list[identifierDotAttribute]
	"""List of class identifiers this class matches, including itself and subclasses with backticks."""
	subclasses: list[str]
	"""List of direct subclass names without backticks or module prefix."""
	parentClass: identifierDotAttribute
	"""The parent class identifier with backticks, e.g., '`ast.stmt`'."""

dictionary_astClasses: dict[str, astClassData] = {}

for astClass in [C for C in [ast.AST, *chain(*(c.__subclasses__() for c in [ast.AST, ast.Constant, *ast.AST.__subclasses__()]))] if issubclass(C, ast.AST)]:
	identifierClass: str = astClass.__name__
	identifierDotClass: identifierDotAttribute = f'`ast.{identifierClass}`'
	subclassList: list[str] = sorted([c.__name__ for c in astClass.__subclasses__() if issubclass(c, ast.AST)], key=lambda s: s.lower())
	matchesClasses: list[identifierDotAttribute] = list(dict.fromkeys([identifierDotClass, *[f'`ast.{name}`' for name in subclassList]]))
	parentClass: identifierDotAttribute = f'`ast.{raiseIfNone(raiseIfNone(astClass.__base__).__name__)}`'

	dictionary_astClasses[identifierClass] = {
		'identifierClass': identifierClass,
		'identifierDotClass': identifierDotClass,
		'matchesClasses': matchesClasses,
		'subclasses': subclassList,
		'parentClass': parentClass,
	}

# https://github.com/hunterhogan/astToolFactory/issues/4

@dataclass(slots=True)
class aDocument:
	"""A document describing something."""

	description: str
	subtitle: str = ''
	AIgenerated: bool = True

@dataclass(slots=True)
class Docstring:
	"""Data to create a docstring."""

	identifier: identifierDotAttribute
	"""The fully qualified identifier of the method, class, function, variable, or module."""
	summary: aDocument
	"""Summarize without new lines."""
	uncategorized: aDocument | None = None
	"""Basic information not otherwise categorized. New lines permitted."""
	Parameters: dict[str, aDocument] = dataclasses.field(default_factory=dict[str, aDocument])
	"""Parameter identifiers mapped to their text descriptions. New lines permitted, but discouraged."""
	Returns: dict[str, aDocument] = dataclasses.field(default_factory=dict[str, aDocument])
	"""Identifiers returned mapped to their text descriptions. If a value is returned without an identifier, create a descriptive proxy
	identifier. New lines permitted, but discouraged."""
	categories: dict[str, aDocument] = dataclasses.field(default_factory=dict[str, aDocument])
	"""Any category name with a text description; category names include 'Examples', 'Raises', and 'See Also'. Use 'Notes' for non-basic
	information not otherwise categorized. New lines permitted."""

	@property
	def AIgenerated(self) -> bool:
		"""True if any part of the docstring was generated by AI."""
		sherpa: bool = False
		if self.uncategorized:
			sherpa = self.uncategorized.AIgenerated
		return (self.summary.AIgenerated and sherpa
			and all(document.AIgenerated for document in itertools.chain(
				self.Parameters.values(), self.Returns.values(), self.categories.values())))

def make1docstring(data: Docstring, ImaIndent: str = ' ' * 4, firstIndent: int = 0) -> str:
	"""Make a docstring from a Docstring dataclass."""
# TODO under-indented.
	indentTo: str = ImaIndent * firstIndent
	paragraph = textwrap.TextWrapper(width=120, initial_indent=indentTo, subsequent_indent=indentTo
		, expand_tabs=True, tabsize=4, replace_whitespace=True, break_long_words=False, drop_whitespace=True)
	paragraphFormatted = textwrap.TextWrapper(width=160, initial_indent=indentTo, subsequent_indent=indentTo
		, expand_tabs=True, tabsize=4, replace_whitespace=False, break_long_words=False, drop_whitespace=True)
	paragraphParameter = textwrap.TextWrapper(width=120, initial_indent=indentTo+ImaIndent, subsequent_indent=indentTo+ImaIndent
		, expand_tabs=True, tabsize=4, replace_whitespace=False, break_long_words=False, drop_whitespace=True)
	docstring: str = f'{data.summary.description}'
	if data.summary.AIgenerated:
		docstring += '\n\n' + paragraph.fill('(AI generated docstring.)')
	if data.uncategorized:
		docstring += '\n\n' + paragraph.fill(data.uncategorized.description)
# TODO type annotations and default values can usually be read from the signature. But some default values are in the logic,
# not the signature.
	if data.Parameters:
		docstring += '\n\n' + paragraph.fill('Parameters')
		docstring += '\n' + paragraph.fill('----------')
		for parameter, description in data.Parameters.items():
			docstring += '\n' + paragraph.fill(f'{parameter} : {description.subtitle}')
			docstring += '\n' + paragraphParameter.fill(description.description)
	if data.Returns:
		docstring += '\n\n' + paragraph.fill('Returns')
		docstring += '\n' + paragraph.fill('-------')
		for returnIdentifier, description in data.Returns.items():
			docstring += '\n' + paragraph.fill(f'{returnIdentifier} : {description.subtitle}')
			docstring += '\n' + paragraphParameter.fill(description.description)
	if data.categories:
		for category, description in data.categories.items():
			docstring += '\n\n' + paragraph.fill(category)
			docstring += '\n' + paragraph.fill(len(category) * '-')
			docstring += '\n' + paragraphFormatted.fill(description.description)
	if len(docstring.splitlines()) > 1:
		docstring += '\n' + indentTo
	return docstring

def getMoreDocstrings() -> None:
	"""Missing docstring in public function."""
	import astToolFactory._documentationAnnex.astTypes  # pyright: ignore[reportUnusedImport]  # noqa: PLC0415
	import astToolFactory._documentationAnnex.Be  # pyright: ignore[reportUnusedImport]  # noqa: PLC0415
	import astToolFactory._documentationAnnex.DOT  # pyright: ignore[reportUnusedImport]  # noqa: PLC0415
	import astToolFactory._documentationAnnex.Grab  # pyright: ignore[reportUnusedImport]  # noqa: PLC0415
	import astToolFactory._documentationAnnex.Make  # pyright: ignore[reportUnusedImport]  # noqa: PLC0415

getMoreDocstrings()
