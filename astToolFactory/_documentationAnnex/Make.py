"""A warehouse for docstrings added to manufactured ast tools.

NOTE Use special indentation in this file.
	1. The generated files use spaces, not tabs, so use spaces here.
	2. As of this writing, I only know how to _manually_ align the indentation of the docstrings with the associated code. So,
		indent one or two levels as appropriate.
"""
from astToolFactory import settingsManufacturing
from astToolFactory.documentation import diminutive2etymology, docstrings
from astToolkit import Make
from dataclasses import dataclass
import ast
import dataclasses
import itertools

@dataclass
class _document:
	description: str
	AIgenerated: bool = True

@dataclass
class Docstring:
	"""Data to create a docstring."""

	summary: _document
	"""Summarize without new lines."""
	uncategorized: _document
	"""Basic information not otherwise categorized. New lines permitted."""
	Parameters: dict[str, _document] = dataclasses.field(default_factory=dict[str, _document])
	"""Parameter identifiers mapped to their text descriptions. New lines permitted, but discouraged."""
	Returns: dict[str, _document] = dataclasses.field(default_factory=dict[str, _document])
	"""Identifiers returned mapped to their text descriptions. If a value is returned without an identifier, create a descriptive proxy
	identifier. New lines permitted, but discouraged."""
	categories: dict[str, _document] = dataclasses.field(default_factory=dict[str, _document])
	"""Any category name with a text description; category names include 'Examples', 'Raises', and 'See Also'. Use 'Notes' for non-basic
	information not otherwise categorized. New lines permitted."""

	@property
	def AIgenerated(self) -> bool:
		"""True if any part of the docstring was generated by AI."""
		return (self.summary.AIgenerated
			and self.uncategorized.AIgenerated
			and all(document.AIgenerated for document in itertools.chain(
				self.Parameters.values(), self.Returns.values(), self.categories.values())))

def _make1docstring(data: Docstring, ImaIndent: str = '\\t', firstIndent: int = 0) -> str:
	"""Make a docstring from a Docstring dataclass."""
	indentTo = ImaIndent * firstIndent
	docstring = indentTo + f'"""{data.summary.description}\n\n'
	if data.summary.AIgenerated:
		docstring += indentTo + '(AI generated docstring)\n\n'
	if data.uncategorized.description:
		docstring += indentTo + data.uncategorized.description + '\n'
	for parameter, description in data.Parameters.items():
		docstring += indentTo + f'{parameter} : {description.description}\n'
	for returnIdentifier, description in data.Returns.items():
		docstring += indentTo + f'{returnIdentifier} : {description.description}\n'
	for category, description in data.categories.items():
		docstring += indentTo + f'{category}\n{description.description}\n'
	docstring += indentTo + '"""\n'
	return docstring

_docstringIdentifier2dataclass: dict[str, Docstring] = {}
identifierToolClass: str = 'Make'
identifierClass = identifierMethod = settingsManufacturing.identifiers[identifierToolClass]

docstrings[identifierClass][identifierMethod] = Make.Expr(Make.Constant(
	f"""Create a `class` `ast.AST` `object` or an `ast.AST` subclass `object`.

	Every non-deprecated subclass of `ast.AST` ({diminutive2etymology['AST']}), has a corresponding method in `Make`, and for each
	`class`, you can set the value of each attribute. But, what is an "attribute"? In the `ast` universe, one word may have many
	different meanings, and if you want to avoid confusion, you should pay close attention to capitalization, leading underscores,
	and context. In Python, an "attribute" is a property of an `object`. In `class` `Make`, when you create an `ast.AST` subclass
	`object`, you can set the value of any attribute of that `object`. The `ast` universe divides attributes into two categories,
	`_attributes` and `_fields` (or `_field*`).

	The attributes in category `_attributes` are `lineno` ({diminutive2etymology['lineno']}), `col_offset`
	({diminutive2etymology['col_offset']}), `end_lineno` ({diminutive2etymology['end_lineno']}), and `end_col_offset`
	({diminutive2etymology['end_col_offset']}). These attributes of an `ast` `object` represent the physical location of the text
	when rendered as Python code. With abstract syntax trees, as opposed to concrete syntax trees for example, you rarely need to
	work directly with physical locations, therefore `_attributes` are almost always relegated to `**keywordArguments` in `Make`
	methods. For a counter example, see `Make.TypeIgnore` ({diminutive2etymology['TypeIgnore']}), for which `lineno` is a named
	parameter.

	In an attempt to distinguish the attributes of `ast.AST` subclasses that are not in the category `_attributes` from the four
	attributes in the category `_attributes`, all other attributes of `ast.AST` subclasses are in category `_fields` (or
	sometimes, category `_field*`, such as `_field_types`).

	You probably want to try to avoid confusing these concepts and categories with similarly named things, including
	`ast.Attribute`, `ast.Attribute.attr` ({diminutive2etymology['attr']}), `getattr`, `setattr`, `ast.MatchClass.kwd_attrs`
	({diminutive2etymology['kwd_attrs']}), and `_Attributes` (no, really, it's a thing).

	Parameters
	----------
	**keywordArguments
		The following are almost always `**keywordArguments`.
	col_offset : int
		({diminutive2etymology['col_offset']}) Position information specifying the column where an AST object begins.
	end_col_offset : (int | None) | int
		({diminutive2etymology['end_col_offset']}) Position information specifying the column where an AST object ends.
	end_lineno : (int | None) | int
		({diminutive2etymology['end_lineno']}) Position information specifying the line number where an AST object ends.
	level : int = 0
		({diminutive2etymology['level']}) An absolute import is "level" 0. A relative import is `level` deep.
	lineno : int
		({diminutive2etymology['lineno']}) Position information manually specifying the line number where an AST object begins.
	type_comment : str
		({diminutive2etymology['type_comment']}) Optional string with the type annotation as a comment or `# type: ignore`.

	"""
))

for subclass in ast.boolop.__subclasses__():
	docstrings[identifierClass][subclass.__name__] = Make.Expr(Make.Constant(f"""Identical to the `ast` ({diminutive2etymology['ast']}) class but with a method, `join()`, that "joins" expressions using the `ast.BoolOp` ({diminutive2etymology['BoolOp']}) class."""))

for subclass in ast.operator.__subclasses__():
	docstrings[identifierClass][subclass.__name__] = Make.Expr(Make.Constant(f"""Identical to the `ast` ({diminutive2etymology['ast']}) class but with a method, `join()`, that "joins" expressions using the `ast.BinOp` ({diminutive2etymology['BinOp']}) class."""))

docstrings[identifierClass][settingsManufacturing.identifiers['boolopJoinMethod']] = Make.Expr(Make.Constant(
		"""'Join' expressions with a boolean operator.

		(AI generated docstring)

		This private method provides the core logic for boolean operator joining used by `And.join()` and `Or.join()` methods. It
		handles edge cases like empty sequences and single expressions while creating properly nested `ast.BoolOp` structures for
		multiple expressions.

		If you are looking for public join functionality, use the specific boolean operator classes (`Make.And.join()`,
		`Make.Or.join()`) instead of this internal method.

		Parameters
		----------
		ast_operator : type[ ast.boolop ]
			The boolean operator type (`ast.And` or `ast.Or`) to use for joining.
		expressions : Sequence[ ast.expr ]
			Sequence of expressions to join with the boolean operator.

		Returns
		-------
		joinedExpression : ast.expr
			Single expression representing the joined boolean operation,
			or the original expression if only one provided.

		"""
))

docstrings[identifierClass]['join_boolop'] = Make.Expr(Make.Constant(
			f"""Make a single `ast.expr` ({diminutive2etymology['expr']}) from a `Sequence` of `ast.expr` by creating an `ast.BoolOp` ({diminutive2etymology['BoolOp']}) `object` that logically "joins" the `Sequence`.

			Like str.join() ({diminutive2etymology['str']}) but for AST ({diminutive2etymology['AST']}) expressions.

			Parameters
			----------
			expressions : Sequence[ ast.expr ]
				Collection of expressions to join.
			**keywordArguments : ast_attributes

			Returns
			-------
			joinedExpression : ast.expr
				Single expression representing the joined expressions.

			Examples
			--------
			Instead of manually constructing ast.BoolOp structures:
			```python
			ast.BoolOp(
				op=ast.And(),
				values=[ast.Name('Lions'), ast.Name('tigers'), ast.Name('bears')]
			)
			```

			Simply use:
			```python
			astToolkit.And.join([ast.Name('Lions'), ast.Name('tigers'), ast.Name('bears')])
			```

			Both produce the same AST structure but the join() method eliminates the manual construction.

			"""
))

docstrings[identifierClass]['_operatorJoinMethod'] = Make.Expr(Make.Constant(
		"""'Join' expressions with a binary operator.

		(AI generated docstring)

		This private method provides the core logic for binary operator joining used by operator classes like `Add.join()`,
		`BitOr.join()`, etc. It creates left-associative nested `ast.BinOp` structures by chaining expressions from left to right.

		If you are looking for public join functionality, use the specific operator classes (`Make.Add.join()`,
		`Make.BitOr.join()`, etc.) instead of this internal method.

		Parameters
		----------
		ast_operator : type[ ast.operator ]
			The binary operator type (like `ast.Add`, `ast.BitOr`) to use for joining.
		expressions : Iterable[ ast.expr ]
			Collection of expressions to join with the binary operator.

		Returns
		-------
		joinedExpression : ast.expr
			Single expression representing the left-associative chained binary operations, or empty string constant if no
			expressions provided.

		"""
))

docstrings[identifierClass]['join_operator'] = Make.Expr(Make.Constant(
			f"""Make a single `ast.expr` ({diminutive2etymology['expr']}) from a `Sequence` of `ast.expr` by creating nested `ast.BinOp` ({diminutive2etymology['BinOp']}) `object` that are logically "joined" by the `ast.operator` subclass.

			Like str.join() ({diminutive2etymology['str']}) but for AST ({diminutive2etymology['AST']}) expressions.

			Parameters
			----------
			expressions : Iterable[ ast.expr ]
				Collection of expressions to join.
			**keywordArguments : ast_attributes

			Returns
			-------
			joinedExpression : ast.expr
				Single expression representing the joined expressions.

			Examples
			--------
			Instead of manually constructing nested ast.BinOp structures:
			```python
			ast.BinOp(
				left=ast.BinOp(
					left=ast.Name('Crosby')
					, op=ast.BitOr()
					, right=ast.Name('Stills'))
				, op=ast.BitOr()
				, right=ast.Name('Nash')
			)
			```

			Simply use:
			```python
			astToolkit.BitOr().join([ast.Name('Crosby'), ast.Name('Stills'), ast.Name('Nash')])
			```

			Both produce the same AST structure but the join() method eliminates the manual nesting.

			"""
))

docstrings[identifierClass]['alias'] = Make.Expr(Make.Constant(
		f"""Import alias AST `object` representing name mapping in import statements.

		(AI generated docstring)

		The `ast.alias` `object` represents name mappings used in `import` and
		`from ... import` statements. It handles both direct imports (`import math`)
		and aliased imports (`import re as regex`).

		Parameters
		----------
		name : str
			The actual module, class, or function name being imported.
		asName : str | None
			Optional {diminutive2etymology['asName']} to use instead of the original name.
			This corresponds to `ast.alias.asname`.

		Returns
		-------
		importAlias: ast.alias
			AST `object` representing an import name mapping with optional aliasing.

		"""
))

docstrings[identifierClass]['AnnAssign'] = Make.Expr(Make.Constant(
		f"""Annotated assignment AST `object` for type-annotated variable assignments.

		(AI generated docstring)

		The `ast.AnnAssign` ({diminutive2etymology['AnnAssign']}) `object` represents variable
		assignments with type annotations, such as `name: int = 42` or `config: dict[str, Any]`.
		This is the preferred form for annotated assignments in modern Python code.

		Parameters
		----------
		target : ast.expr
			The assignment target, which must be a simple name, attribute access,
			or subscript operation that can receive the annotated assignment.
		annotation : ast.expr
			The type annotation expression specifying the variable's expected type.
		value : ast.expr | None = None
			Optional initial value expression for the annotated variable.

		Returns
		-------
		annotatedAssignment : ast.AnnAssign
			AST `object` representing a type-annotated variable assignment.

		"""
))

docstrings[identifierClass]['arg'] = Make.Expr(Make.Constant(
		f"""Make an `ast.arg` ({diminutive2etymology['arg']}) object representing individual arguments in function signatures.

		The `ast.arg` ({diminutive2etymology['ast']}) object represents a single parameter in function definitions, including
		positional, keyword-only, and special parameters like `*arguments` and `**keywordArguments`. Contains the parameter name
		and optional type annotation.

		Parameters
		----------
		Buffalo_buffalo_Buffalo_buffalo_buffalo_buffalo_Buffalo_buffalo: str
			Parameter name as string. This corresponds to `ast.arg.arg`; and in an `ast.FunctionDef`
			({diminutive2etymology['FunctionDef']}) `object`, it corresponds to `ast.FunctionDef.args.args[n].arg.arg`, which has
			the same semantic value as `Buffalo_buffalo_Buffalo_buffalo_buffalo_buffalo_Buffalo_buffalo`.
		annotation : ast.expr | None
			Optional type annotation expression for the parameter.

		Returns
		-------
		argumentDefinition : ast.arg
			AST object representing a single function parameter with optional typing.

		"""
))

docstrings[identifierClass]['arguments'] = Make.Expr(Make.Constant(
		f"""Make a function signature AST object containing all parameter specifications.

		(AI generated docstring)

		The `ast.arguments` object represents the complete parameter specification
		for function definitions, organizing different parameter types including
		positional-only, regular, keyword-only, variadic, and default values.

		Parameters
		----------
		posonlyargs : list[ ast.arg ] = [ ]
			({diminutive2etymology['posonlyargs']}) List of positional-only parameters (before /).
		list_arg : list[ ast.arg ] = [ ]
			({diminutive2etymology['list_arg']}) List of positional parameters. This corresponds to `ast.arguments.args`.
		vararg : ast.arg | None = None
			({diminutive2etymology['vararg']}) Single parameter for *arguments variadic arguments.
		kwonlyargs : list[ ast.arg ] = [ ]
			({diminutive2etymology['kwonlyargs']}) List of keyword-only parameters (after * or *arguments).
		kw_defaults : Sequence[ ast.expr | None ] = [ None ]
			({diminutive2etymology['kw_defaults']}) Default values for keyword-only parameters; None indicates required.
		kwarg : ast.arg | None = None
			({diminutive2etymology['kwarg']}) Single parameter for "**keywordArguments" keyword arguments.
		defaults : Sequence[ ast.expr ] = [ ]
			Default values for regular positional parameters.

		Returns
		-------
		functionSignature : ast.arguments
			AST object representing complete function parameter specification.

		"""
))

docstrings[identifierClass]['Assert'] = Make.Expr(Make.Constant(
		f"""Create an `ast.Assert` node for assertion statements.

		(AI generated docstring)

		The `Assert` node represents an `assert` statement that evaluates a test
		expression and optionally raises `AssertionError` with a message if the
		test fails. This is primarily used for debugging and testing purposes.

		Parameters
		----------
		test : ast.expr
			Expression to evaluate for truthiness.
		msg : ast.expr | None = None
			({diminutive2etymology['msg']}) Optional expression for the assertion error message.

		Returns
		-------
		nodeAssert : ast.Assert
			The constructed assertion node.

		"""
))

docstrings[identifierClass]['AST'] = Make.Expr(Make.Constant(
		f"""Make a base AST ({diminutive2etymology['AST']}) node object representing the abstract syntax tree foundation.

		(AI generated docstring)

		The `ast.AST` object serves as the base class for all AST node types in Python's
		abstract syntax tree. This method creates a minimal AST instance, though in practice
		you will typically use specific node type factories like `Make.Name()`, `Make.Call()`,
		etc.

		Most users seeking AST node creation should use the specific factory methods for
		concrete node types rather than this base AST constructor.

		Returns
		-------
		baseNode : ast.AST
			The fundamental AST object from which all other nodes inherit.

		"""
))

docstrings[identifierClass]['Assign'] = Make.Expr(Make.Constant(
		"""Make an assignment AST `object` for variable assignments without type annotations.

		(AI generated docstring)

		The `ast.Assign` `object` represents traditional variable assignments like
		`x = 5`, `a = b = c`, or `items[0] = newValue`. It supports multiple assignment
		targets and complex assignment patterns.

		Parameters
		----------
		targets : Sequence[ast.expr]
			Sequence of assignment targets that will receive the value.
			Multiple targets enable chained assignments like `a = b = value`.
		value : ast.expr
			The expression whose result will be assigned to all targets.

		Returns
		-------
		assignment : ast.Assign
			AST `object` representing a variable assignment operation.

		"""
))

docstrings[identifierClass]['AsyncFor'] = Make.Expr(Make.Constant(
		f"""Asynchronous for loop AST `object` for iterating over async iterables.

		(AI generated docstring)

		The `ast.AsyncFor` ({diminutive2etymology['AsyncFor']}) `object` represents `async for`
		loops that iterate over asynchronous iterators and async generators. These loops can only
		exist within async functions and automatically handle await operations.

		Parameters
		----------
		target : ast.expr
			The loop variable that receives each item from the async iterable.
		iter : ast.expr
			({diminutive2etymology['iter']}) The asynchronous iterable expression being iterated over.
		body : Sequence[ast.stmt]
			Sequence of statements executed for each iteration of the async loop.
		orelse : Sequence[ast.stmt] = []
			({diminutive2etymology['orElse']}) Optional statements executed when the loop completes normally
			without encountering a break statement.

		Returns
		-------
		asyncForLoop : ast.AsyncFor
			AST `object` representing an asynchronous for loop construct.

		"""
))

docstrings[identifierClass]['AsyncFunctionDef'] = Make.Expr(Make.Constant(
		f"""Asynchronous function definition AST object for `async def` ({diminutive2etymology['async']} {diminutive2etymology['def']}) declarations.

		(AI generated docstring)

		The `ast.AsyncFunctionDef` ({diminutive2etymology['AsyncFunctionDef']}) object represents
		asynchronous function definitions using the `async def` syntax. Supports coroutines, async
		generators, and other asynchronous operations with await expressions.

		Parameters
		----------
		name : str
			Function name as string identifier.
		args : ast.arguments = ast.arguments()
			Function parameter specification.
		body : Sequence[ast.stmt] = []
			List of statements forming the function body.
		decorator_list : Sequence[ast.expr] = []
			List of decorator expressions applied to function.
		returns : ast.expr | None = None
			({diminutive2etymology['returns']}) Optional return type annotation expression.
		type_params : Sequence[ast.type_param] = []
			({diminutive2etymology['type_params']}) List of type parameters for generic functions (Python 3.12+).

		Returns
		-------
		asyncFunction : ast.AsyncFunctionDef
			AST object representing an asynchronous function definition.

		"""
))

docstrings[identifierClass]['AsyncWith'] = Make.Expr(Make.Constant(
		f"""Asynchronous context manager AST `object` for async resource management.

		(AI generated docstring)

		The `ast.AsyncWith` ({diminutive2etymology['AsyncWith']}) `object` represents `async with`
		statements that manage asynchronous context managers. These ensure proper setup and cleanup
		of async resources like database connections or file handles.

		Parameters
		----------
		items : Sequence[ast.withitem]
			Sequence of context manager items, each specifying an async context
			manager and optional variable binding for the managed resource.
		body : Sequence[ast.stmt]
			Sequence of statements executed within the async context manager scope.

		Returns
		-------
		asyncWithStatement : ast.AsyncWith
			AST `object` representing an asynchronous context manager statement.

		"""
))

docstrings[identifierClass]['Attribute'] = Make.Expr(Make.Constant(
		"""Attribute access AST `object` representing dot notation in Python code.

		(AI generated docstring)

		The `ast.Attribute` `object` represents attribute access using dot notation, such as
		`object.attribute` or chained access like `module.class.method`. This method
		supports chaining multiple attributes by passing additional attribute names.

		Parameters
		----------
		value : ast.expr
			The base expression before the first dot, typically an `ast.Name` or another expression.
		attribute : str
			One or more attribute names to chain together with dot notation.
		context : ast.expr_context = ast.Load()
			Are you loading from, storing to, or deleting the `ast.Attribute`? Values may be
			`ast.Load()`, `ast.Store()`, or `ast.Del()`, meaning 'Delete' the `ast.Attribute`.
			`context` corresponds to `ast.Attribute.ctx`.

		Returns
		-------
		attributeAccess: ast.Attribute
			AST `object` representing attribute access with potential chaining.

		"""
))

docstrings[identifierClass]['AugAssign'] = Make.Expr(Make.Constant(
		f"""Augmented assignment AST `object` for compound assignment operations.

		(AI generated docstring)

		The `ast.AugAssign` ({diminutive2etymology['AugAssign']}) `object` represents augmented
		assignment operators like `+=`, `-=`, `*=`, `/=`, and others that combine an operation with
		assignment. These provide concise syntax for modifying variables in-place.

		Parameters
		----------
		target : ast.expr
			The assignment target being modified, which must be a name,
			attribute access, or subscript that supports in-place modification.
		op : ast.operator
			({diminutive2etymology['op']}) The binary operator defining the augmentation operation, such as
			`ast.Add()` for `+=` or `ast.Mult()` ({diminutive2etymology['Mult']}) for `*=`.
		value : ast.expr
			The expression whose result will be combined with the target
			using the specified operator.

		Returns
		-------
		augmentedAssignment : ast.AugAssign
			AST `object` representing a compound assignment operation.

		"""
))

docstrings[identifierClass]['Await'] = Make.Expr(Make.Constant(
		f"""Await expression AST `object` for asynchronous operations.

		(AI generated docstring)

		The `ast.Await` ({diminutive2etymology['Await']}) `object` represents the keyword `await`
		used with asynchronous expressions in Python. It can only be used within async functions and
		suspends execution until the awaited coroutine completes.

		Parameters
		----------
		value : ast.expr
			The expression to await, typically a coroutine or awaitable `object`.

		Returns
		-------
		awaitExpression : ast.Await
			AST `object` representing an await expression for asynchronous code.

		"""
))

docstrings[identifierClass]['BinOp'] = Make.Expr(Make.Constant(
		f"""Make a binary operation AST `object` representing operators between two expressions.

		(AI generated docstring)

		The `ast.BinOp` ({diminutive2etymology['BinOp']}) `object` represents binary operations like
		addition, subtraction, multiplication, and other two-operand operations. The operation type
		is determined by the `op` parameter using specific operator classes.

		Parameters
		----------
		left : ast.expr
			The left-hand operand expression.
		op : ast.operator
			The binary operator, such as `ast.Add()`, `ast.Sub()`, `ast.Mult()`, etc.
		right : ast.expr
			The right-hand operand expression.

		Returns
		-------
		binaryOperation : ast.BinOp
			AST `object` representing a binary operation between two expressions.

		"""
))

docstrings[identifierClass]['boolop'] = Make.Expr(Make.Constant(
		f"""Make a base boolean operator abstract class for logical operations.

		(AI generated docstring)

		The `ast.boolop` ({diminutive2etymology['boolop']}) class serves as the abstract base for
		boolean operators like `ast.And` and `ast.Or`. This method creates a minimal boolop
		instance, though in practice you will typically use specific boolean operator factories like
		`Make.And()`, `Make.Or()`, or their join methods.

		Most users seeking boolean operation creation should use the specific operator
		classes or `Make.BoolOp()` rather than this abstract base constructor.

		Returns
		-------
		baseBooleanOperator : ast.boolop
			({diminutive2etymology['boolop']}) AST `object` representing a base boolean operator.

		"""
))

docstrings[identifierClass]['BoolOp'] = Make.Expr(Make.Constant(
		f"""Make a boolean operation AST `object` for logical operations with multiple operands.

		(AI generated docstring)

		The `ast.BoolOp` ({diminutive2etymology['BoolOp']}) `object` represents boolean operations
		like keywords `and` and `or` that can operate on multiple expressions. Unlike binary
		operators, boolean operations can chain multiple values together efficiently.

		Parameters
		----------
		op : ast.boolop
			({diminutive2etymology['boolop']}) The boolean operator, either `ast.And()` or `ast.Or()`.
		values : Sequence[ast.expr]
			Sequence of expressions to combine with the boolean operator.

		Returns
		-------
		booleanOperation : ast.BoolOp
			({diminutive2etymology['BoolOp']}) AST `object` representing a boolean operation with multiple operands.

		"""
))

docstrings[identifierClass]['Break'] = Make.Expr(Make.Constant(
		"""Create an `ast.Break` node for break statements.

		(AI generated docstring)

		The `Break` node represents a `break` statement that terminates the
		nearest enclosing loop. Can only be used within loop constructs.

		Returns
		-------
		nodeBreak : ast.Break
			The constructed break statement node.

		"""
))

docstrings[identifierClass]['Call'] = Make.Expr(Make.Constant(
		"""Make a function call AST `object` representing function invocation with arguments.

		(AI generated docstring)

		The `ast.Call` `object` represents function calls, method calls, and constructor
		invocations. It supports both positional and keyword arguments and handles various calling
		conventions including unpacking operators.

		Parameters
		----------
		callee : ast.expr
			The callable expression, typically a function name or method access.
		listParameters : Sequence[ast.expr] = []
			Sequence of positional argument expressions.
		list_keyword : Sequence[ast.keyword] = []
			Sequence of keyword arguments as `ast.keyword`.

		Returns
		-------
		functionCall : ast.Call
			AST `object` representing a function call with specified arguments.

		"""
))

docstrings[identifierClass]['ClassDef'] = Make.Expr(Make.Constant(
		f"""Make a class definition AST object for `class` declarations with inheritance and metadata.

		(AI generated docstring)

		The `ast.ClassDef` object represents class definitions including base classes,
		metaclass specifications, decorators, and the class body. Supports both
		traditional and modern Python class features.

		Parameters
		----------
		name : str
			Class name as string identifier.
		bases : Sequence[ast.expr] = []
			List of base class expressions for inheritance.
		keywords : Sequence[ast.keyword] = []
			({diminutive2etymology['list_keyword']}) including metaclass specifications.
		body : Sequence[ast.stmt] = []
			List of statements forming the class body.
		decorator_list : Sequence[ast.expr] = []
			List of decorator expressions applied to class.
		type_params : Sequence[ast.type_param] = []
			({diminutive2etymology['type_params']}) List of type parameters for generic classes (Python 3.12+).

		Returns
		-------
		classDefinition : ast.ClassDef
			AST object representing a complete class definition with metadata.

		Examples
		--------
		# Creates AST equivalent to: class Vehicle: pass
		simpleClass = Make.ClassDef('Vehicle', body=[Make.Pass()])

		# Creates AST equivalent to: class Bicycle(Vehicle, metaclass=ABCMeta): pass
		inheritedClass = Make.ClassDef(
			'Bicycle',
			bases=[Make.Name('Vehicle')],
			keywords=[Make.keyword('metaclass', Make.Name('ABCMeta'))],
			body=[Make.Pass()]
		)

		"""
))

docstrings[identifierClass]['cmpop'] = Make.Expr(Make.Constant(
		f"""`class` `ast.cmpop`, {diminutive2etymology['cmpop']}, is the parent (or "base") class of all comparison operator classes used in `ast.Compare`.

		It is the abstract parent for: `ast.Eq`, `ast.NotEq`, `ast.Lt`, `ast.LtE`, `ast.Gt`,
		`ast.GtE`, `ast.Is`, `ast.IsNot`, `ast.In`, `ast.NotIn`. This factory method makes a generic
		comparison operator `object` that can be used in the antecedent-action pattern with visitor
		classes.

		Returns
		-------
		comparisonOperator: ast.cmpop
			Abstract comparison operator `object` that serves as the base `class` for all Python
			comparison operators in AST structures.

		"""
))

docstrings[identifierClass]['Compare'] = Make.Expr(Make.Constant(
		f"""Make a comparison AST `object` for chained comparison operations.

		(AI generated docstring)

		The `ast.Compare` `object` represents comparison operations including equality, inequality,
		and ordering comparisons. It supports chained comparisons like `a < b <= c` through
		sequences of operators and comparators.

		All comparison operators: `ast.Eq` ({diminutive2etymology['Eq']}), `ast.NotEq`
		({diminutive2etymology['NotEq']}), `ast.Lt` ({diminutive2etymology['Lt']}), `ast.LtE`
		({diminutive2etymology['LtE']}), `ast.Gt` ({diminutive2etymology['Gt']}), `ast.GtE`
		({diminutive2etymology['GtE']}), `ast.Is`, `ast.IsNot`, `ast.In`, `ast.NotIn`
		({diminutive2etymology['NotIn']}).

		Parameters
		----------
		left : ast.expr
			({diminutive2etymology['left']}) The leftmost expression in the comparison chain.
		ops : Sequence[ast.cmpop]
			({diminutive2etymology['ops']}) Sequence of comparison operators from the complete list above.
		comparators : Sequence[ast.expr]
			Sequence of expressions to compare against, one for each operator.

		Returns
		-------
		comparison : ast.Compare
			AST `object` representing a comparison operation with potential chaining.

		Examples
		--------
		```python
		# Creates AST equivalent to: `temperature == 72`
		temperatureCheck = Make.Compare(
			left=Make.Name('temperature'),
			ops=[Make.Eq()],
			comparators=[Make.Constant(72)]
		)

		# Creates AST equivalent to: `0 <= inventory < 100`
		inventoryRange = Make.Compare(
			left=Make.Constant(0),
			ops=[Make.LtE(), Make.Lt()],
			comparators=[Make.Name('inventory'), Make.Constant(100)]
		)
		```

		"""
))

docstrings[identifierClass]['comprehension'] = Make.Expr(Make.Constant(
		f"""Make a comprehension clause AST object for `for` clauses in list/set/dict comprehensions.

		(AI generated docstring)

		The `ast.comprehension` object represents individual `for` clauses within
		comprehension expressions. Contains the iteration target, source, conditional
		filters, and async specification for generator expressions.

		Parameters
		----------
		target : ast.expr
			Variable expression receiving each iteration value.
		iter : ast.expr
			({diminutive2etymology['iter']}) Iterable expression being traversed.
		ifs : Sequence[ast.expr] = []
			({diminutive2etymology['ifs']}) List of conditional expressions filtering iteration results.
		is_async : int = 0
			({diminutive2etymology['is_async']}) Integer flag (0 or 1) indicating async comprehension.

		Returns
		-------
		comprehensionClause : ast.comprehension
			AST object representing a single for clause in comprehensions.

		"""
))

docstrings[identifierClass]['Constant'] = Make.Expr(Make.Constant(
		"""Make a constant value AST `object` for literal values in Python code.

		(AI generated docstring)

		The `ast.Constant` `object` represents literal constant values like numbers, strings,
		booleans, and None. It replaces the deprecated specific literal and provides a unified
		representation for all constant values.

		Parameters
		----------
		value : ConstantValueType
			The constant value.
		kind : str | None = None
			Optional string hint for specialized constant handling.

		Returns
		-------
		constantValue : ast.Constant
			AST `object` representing a literal constant value.

		"""
))

docstrings[identifierClass]['Continue'] = Make.Expr(Make.Constant(
		"""Create an `ast.Continue` node for continue statements.

		(AI generated docstring)

		The `Continue` node represents a `continue` statement that skips the
		remainder of the current iteration and continues with the next iteration
		of the nearest enclosing loop.

		Returns
		-------
		nodeContinue : ast.Continue
			The constructed continue statement node.

		"""
))

docstrings[identifierClass]['Del'] = Make.Expr(Make.Constant(
		f"""Make a delete context for removing expressions from memory.

		(AI generated docstring)

		The `ast.Del` ({diminutive2etymology['Del']}) context indicates expressions are deletion targets in `del`
		statements. Note that `ast.Del` is the expression context, not the `del`
		keyword itself - `ast.Delete` represents the `del` statement.

		Returns
		-------
		deleteContext : ast.Del
			AST context object indicating deletion operations on expressions.

		Examples
		--------
		Creates AST equivalent to deletion: del bicycle.wheel
		```python
		wheelDeletion = Make.Attribute(Make.Name('bicycle'), 'wheel', Make.Del())
		```

		"""
))

docstrings[identifierClass]['Delete'] = Make.Expr(Make.Constant(
		"""Create an `ast.Delete` node for deletion statements.

		(AI generated docstring)

		The `Delete` node represents a `del` statement that removes references
		to objects. Can delete variables, attributes, subscripts, or slices.

		Parameters
		----------
		targets : Sequence[ast.expr]
			List of expressions identifying what to delete.

		Returns
		-------
		nodeDelete : ast.Delete
			The constructed deletion statement node.

		"""
))

docstrings[identifierClass]['Dict'] = Make.Expr(Make.Constant(
		f"""Combine `keys` and `values` into an AST ({diminutive2etymology['AST']}) representation of the Python built-in `class` `dict` ({diminutive2etymology['dict']}).

		(AI generated docstring)

		The `ast.Dict` ({diminutive2etymology['Dict']}) `object` represents dictionary literals
		using curly brace notation. It supports both regular key-value pairs and dictionary
		unpacking operations where keys can be None to indicate unpacking expressions.

		Parameters
		----------
		keys : Sequence[ast.expr | None] = [None]
			Sequence of key expressions or None for unpacking operations.
		values : Sequence[ast.expr] = []
			Sequence of value expressions corresponding to the keys.

		Returns
		-------
		dictionaryLiteral : ast.Dict
			({diminutive2etymology['Dict']}) AST `object` representing a dictionary literal with specified key-value pairs.

		"""
))

docstrings[identifierClass]['DictComp'] = Make.Expr(Make.Constant(
		f"""Make a dictionary comprehension AST `object` for dynamic dictionary construction.

		(AI generated docstring)

		The `ast.DictComp` ({diminutive2etymology['DictComp']}) `object` represents dictionary
		comprehensions that make dictionaries using iterator expressions. It combines key-value
		generation with filtering and nested iteration capabilities.

		Parameters
		----------
		key : ast.expr
			Expression that generates dictionary keys.
		value : ast.expr
			Expression that generates dictionary values.
		generators : Sequence[ast.comprehension]
			Sequence of `ast.comprehension` defining iteration and filtering.

		Returns
		-------
		dictionaryComprehension : ast.DictComp
			({diminutive2etymology['DictComp']}) AST `object` representing a dictionary comprehension expression.

		Examples
		--------
		```python
		# Creates AST equivalent to: `{{recipe: difficulty for recipe in cookbook}}`
		recipeDifficulty = Make.DictComp(
			key=Make.Name('recipe'),
			value=Make.Name('difficulty'),
			generators=[Make.comprehension(
				target=Make.Name('recipe'),
				iter=Make.Name('cookbook'),
				ifs=[]
			)]
		)
		```

		"""
))

docstrings[identifierClass]['Eq'] = Make.Expr(Make.Constant(
		"""'Eq', meaning 'is ***Eq***ual to', is the `object` representation of Python comparison operator '`==`'.

		`class` `ast.Eq` is a subclass of `ast.cmpop`, '***c***o***mp***arison ***op***erator', and
		only used in `class` `ast.Compare`, parameter '`ops`', ***op***erator***s***.

		Returns
		-------
		equalityOperator:
			AST `object` representing the '`==`' equality comparison operator for use
			in `ast.Compare`.

		"""
))

docstrings[identifierClass]['excepthandler'] = Make.Expr(Make.Constant(
		f"""Exception handler abstract base class for try-except constructs.

		(AI generated docstring)

		The `ast.excepthandler` ({diminutive2etymology['excepthandler']}) abstract base class
		represents exception handling clauses in try-except statements. This is the foundation for
		`ast.ExceptHandler` which implements the actual exception catching logic.

		Returns
		-------
		exceptionHandler : ast.excepthandler
			Abstract AST object for exception handling clause classification.

		"""
))

docstrings[identifierClass]['ExceptHandler'] = Make.Expr(Make.Constant(
		f"""Exception handler clause for try-except statements.

		(AI generated docstring)

		The `ast.ExceptHandler` ({diminutive2etymology['ExceptHandler']}) object represents
		individual `except` clauses that catch and handle specific exceptions. It defines the
		exception type to catch, optional variable binding, and statements to execute when matched.

		Parameters
		----------
		type : ast.expr | None = None
			Exception type expression to catch; None catches all exceptions.
		name : str | None = None
			Variable name string to bind caught exception; None for no binding.
		body : Sequence[ast.stmt] = []
			List of statements to execute when exception is caught.

		Returns
		-------
		exceptionHandler : ast.ExceptHandler
			AST object representing an except clause in try-except statements.

		"""
))

docstrings[identifierClass]['expr'] = Make.Expr(Make.Constant(
		"""Abstract ***expr***ession `object` for base expression operations.

		(AI generated docstring)

		The `ast.expr` class serves as the abstract base class for all expression
		objects in Python's AST. Unlike `ast.stmt` which represents statements that
		perform actions, `ast.expr` represents expressions that evaluate to values
		and can be used within larger expressions or as parts of statements.

		Expressions vs Statements:
		- **expr**: Evaluates to a value and can be composed into larger expressions.
		  Examples include literals (`42`, `"hello"`), operations (`x + y`),
		  function calls (`len(data)`), and attribute access (`obj.method`).
		- **stmt**: Performs an action and does not evaluate to a usable value.
		  Examples include assignments (`x = 5`), control flow (`if`, `for`, `while`),
		  function definitions (`def`), and imports (`import`).

		Returns
		-------
		expression: ast.expr
			Abstract expression `object` that serves as the base class for all
			Python expressions in AST structures.

		"""
))

docstrings[identifierClass]['Expr'] = Make.Expr(Make.Constant(
		"""Create an `ast.Expr` node for expression statements.

		(AI generated docstring)

		The `Expr` node represents a statement that consists of a single expression
		whose value is discarded. This is used for expressions evaluated for their
		side effects rather than their return value.

		Parameters
		----------
		value : ast.expr
			Expression to evaluate as a statement.

		Returns
		-------
		nodeExpr : ast.Expr
			The constructed expression statement node.

		"""
))

docstrings[identifierClass]['expr_context'] = Make.Expr(Make.Constant(
		f"""Expression context abstract base class for expression usage patterns.

		(AI generated docstring)

		The `ast.expr_context` ({diminutive2etymology['expr_context']}) abstract base class
		represents how expressions are used in code: whether they load values, store values, or
		delete them. This is the foundation for `ast.Load`, `ast.Store`, and `ast.Del` contexts.

		Returns
		-------
		expressionContext : ast.expr_context
			Abstract AST context object for expression usage classification.

		"""
))

docstrings[identifierClass]['Expression'] = Make.Expr(Make.Constant(
		"""Create an `ast.Expression` node for expression-only modules.

		(AI generated docstring)

		The `Expression` node represents a module that contains only a single
		expression. This is used in contexts where only an expression is expected,
		such as with `eval()` or interactive mode single expressions.

		Parameters
		----------
		body : ast.expr
			The single expression that forms the module body

		Returns
		-------
		nodeExpression : ast.Expression
			The constructed expression module node

		"""
))

docstrings[identifierClass]['For'] = Make.Expr(Make.Constant(
		f"""Make a for loop AST `object` for iterating over iterable expressions.

		(AI generated docstring)

		The `ast.For` `object` represents traditional `for` loops that iterate over
		sequences, generators, or any iterable object. It supports optional else
		clauses that execute when the loop completes normally.

		Parameters
		----------
		target : ast.expr
			The loop variable that receives each item from the iterable expression.
		iter : ast.expr
			({diminutive2etymology['iter']}) The iterable expression being iterated over, such as a list, range, or generator.
		body : Sequence[ast.stmt]
			Sequence of statements executed for each iteration of the loop.
		orelse : Sequence[ast.stmt] = []
			({diminutive2etymology['orElse']}) Optional statements executed when the loop completes normally
			without encountering a break statement.

		Returns
		-------
		forLoop : ast.For
			AST `object` representing a for loop iteration construct.

		"""
))

docstrings[identifierClass]['FormattedValue'] = Make.Expr(Make.Constant(
		f"""Make a formatted value AST `object` for f-string interpolation components.

		The `ast.FormattedValue` `object` represents individual expressions within f-string
		literals, including format specifications and conversion options. It handles the
		interpolation mechanics of formatted string literals.

		Parameters
		----------
		value : ast.expr
			The expression to be formatted and interpolated.
		conversion : int
			Conversion flag (0=no conversion, 115='s', 114='r', 97='a').
		format_spec : ast.expr | None
			({diminutive2etymology['format_spec']}) Optional format specification expression.

		Returns
		-------
		formattedValue : ast.FormattedValue
			AST `object` representing a formatted value within an f-string expression.

		"""
))

docstrings[identifierClass]['FunctionDef'] = Make.Expr(Make.Constant(
		f"""Make a function definition AST object for standard `def` declarations with typing support.

		(AI generated docstring)

		The `ast.FunctionDef` object represents standard function definitions including
		parameters, return annotations, decorators, and function body. Supports modern
		Python typing features and generic type parameters.

		Parameters
		----------
		name : str
			Function name as string identifier.
		args : ast.arguments = ast.arguments()
			Function parameter specification.
		body : Sequence[ast.stmt] = []
			List of statements forming the function body.
		decorator_list : Sequence[ast.expr] = []
			List of decorator expressions applied to function.
		returns : ast.expr | None = None
			({diminutive2etymology['returns']}) Optional return type annotation expression.
		type_params : Sequence[ast.type_param] = []
			({diminutive2etymology['type_params']}) List of type parameters for generic functions (Python 3.12+).

		Returns
		-------
		functionDefinition : ast.FunctionDef
			AST object representing a complete function definition with metadata.

		Examples
		--------
		# Creates AST equivalent to: def cook(): pass
		simpleFunction = Make.FunctionDef('cook', body=[Make.Pass()])

		# Creates AST equivalent to: def bake(recipe: str, temperature: int = 350) -> bool: return True
		typedFunction = Make.FunctionDef(
			'bake',
			Make.arguments(
				args=[Make.arg('recipe', Make.Name('str')), Make.arg('temperature', Make.Name('int'))],
				defaults=[Make.Constant(350)]
			),
			[Make.Return(Make.Constant(True))],
			returns=Make.Name('bool')
		)

		"""
))

docstrings[identifierClass]['FunctionType'] = Make.Expr(Make.Constant(
		f"""Create an `ast.FunctionType` ({diminutive2etymology['FunctionType']}) node for function type annotations.

		(AI generated docstring)

		The `FunctionType` node represents function type annotations of the form
		`(arg_types) -> return_type`. This is used in type annotations and
		variable annotations for callable types.

		Parameters
		----------
		argtypes : Sequence[ast.expr] = []
			({diminutive2etymology['argtypes']}) List of expressions representing argument types
		returns : ast.expr
			({diminutive2etymology['returns']}) Expression representing the return type

		Returns
		-------
		nodeFunctionType : ast.FunctionType
			The constructed function type annotation node

		"""
))

docstrings[identifierClass]['GeneratorExp'] = Make.Expr(Make.Constant(
		f"""Make a generator expression object for memory-efficient iteration.

		The `ast.GeneratorExp` ({diminutive2etymology['GeneratorExp']}) object represents generator
		expressions that create iterator objects without constructing intermediate collections. It
		provides lazy evaluation and memory efficiency for large datasets.

		Parameters
		----------
		element : ast.expr
			Expression that generates each element of the generator.
		generators : list[ast.comprehension]
			Sequence of `ast.comprehension` objects defining iteration and filtering.

		Returns
		-------
		generatorExpression : ast.GeneratorExp
			AST object representing a generator expression for lazy evaluation.

		"""
))

docstrings[identifierClass]['Global'] = Make.Expr(Make.Constant(
		"""Create an `ast.Global` node for global declarations.

		(AI generated docstring)

		The `Global` node represents a `global` statement that declares variables
		as referring to global scope rather than local scope. This affects variable
		lookup and assignment within the current function.

		Parameters
		----------
		names : Sequence[str]
			List of variable names to declare as global.

		Returns
		-------
		nodeGlobal : ast.Global
			The constructed global declaration node.

		"""
))

docstrings[identifierClass]['Gt'] = Make.Expr(Make.Constant(
		"""'Gt', meaning 'Greater than', is the `object` representation of Python operator '`>`'.

		`class` `ast.Gt` is a subclass of `ast.cmpop`, '***c***o***mp***arison ***op***erator', and
		only used in `class` `ast.Compare`, parameter '`ops`', ***op***erator***s***.

		Returns
		-------
		greaterThanOperator:
			AST `object` representing the '`>`' greater-than comparison operator for use
			in `ast.Compare`.

		"""
))

docstrings[identifierClass]['GtE'] = Make.Expr(Make.Constant(
		"""'GtE', meaning 'is Greater than or Equal to', is the `object` representation of Python comparison operator '`>=`'.

		`class` `ast.GtE` is a subclass of `ast.cmpop`, '***c***o***mp***arison ***op***erator', and
		only used in `class` `ast.Compare`, parameter '`ops`', ***op***erator***s***.

		Returns
		-------
		greaterThanOrEqualOperator:
			AST `object` representing the '`>=`' greater-than-or-equal comparison operator
			for use in `ast.Compare`.

		"""
))

docstrings[identifierClass]['If'] = Make.Expr(Make.Constant(
		f"""Make a conditional statement AST `object` for branching execution paths.

		(AI generated docstring)

		The `ast.If` `object` represents `if` statements that conditionally execute
		code blocks based on boolean test expressions. It supports optional else
		clauses for alternative execution paths.

		Parameters
		----------
		test : ast.expr
			The boolean expression that determines which branch to execute.
		body : Sequence[ast.stmt]
			Sequence of statements executed when the test expression evaluates to True.
		orElse : Sequence[ast.stmt] = []
			({diminutive2etymology['orElse']}) Optional statements executed when the test expression evaluates to False. This
			parameter corresponds with `ast.If.orelse` ({diminutive2etymology['orelse']}).

		Returns
		-------
		conditionalStatement : ast.If
			AST `object` representing a conditional branching statement.

		Examples
		--------
		```python
		# Creates AST for: if userLoggedIn:
		#                     showDashboard()
		simpleIf = Make.If(
			Make.Name('userLoggedIn'),
			[Make.Expr(Make.Call(Make.Name('showDashboard')))]
		)

		# Creates AST for: if temperature > 100:
		#                     activateCooling()
		#                 else:
		#                     maintainTemperature()
		ifElse = Make.If(
			Make.Compare(Make.Name('temperature'), [Make.Gt()], [Make.Constant(100)]),
			[Make.Expr(Make.Call(Make.Name('activateCooling')))],
			[Make.Expr(Make.Call(Make.Name('maintainTemperature')))]
		)

		# Creates AST for nested if-elif-else chains
		ifElifElse = Make.If(
			Make.Compare(Make.Name('score'), [Make.GtE()], [Make.Constant(90)]),
			[Make.Assign([Make.Name('grade')], Make.Constant('A'))],
			[Make.If(
				Make.Compare(Make.Name('score'), [Make.GtE()], [Make.Constant(80)]),
				[Make.Assign([Make.Name('grade')], Make.Constant('B'))],
				[Make.Assign([Make.Name('grade')], Make.Constant('C'))]
			)]
		)
		```

		"""
))

docstrings[identifierClass]['IfExp'] = Make.Expr(Make.Constant(
		f"""Make a 'ChooseThis `if` ConditionIsTrue `else` ChooseThat' conditional expression.

		The `ast.IfExp` ({diminutive2etymology['IfExp']}) `object` represents inline conditional
		expressions using the ternary operator syntax `execute_if_true if condition else
		execute_if_false`.

		Parameters
		----------
		test : ast.expr
			The `True`/`False` condition expression.
		body : ast.expr
			If `test` is `True`, the interpreter executes this singular expression.
		orElse : ast.expr
			({diminutive2etymology['orElse']}) If `test` is `False`, the interpreter executes this singular expression. This
			parameter corresponds with `ast.IfExp.orelse` ({diminutive2etymology['orelse']}).

		Returns
		-------
		conditionalExpression : ast.IfExp
			`ast.AST` ({diminutive2etymology['AST']}) `object` representing an inline conditional expression.

		Examples
		--------
		```python
		# To create the `ast.AST` representation of `maxVolume if amplified else defaultVolume`:
		Make.IfExp(
			test = Make.Name('amplified'),
			body = Make.Name('maxVolume'),
			orElse = Make.Name('defaultVolume')
		)

		# To create the `ast.AST` representation of `"sunny" if weather > 70 else "cloudy"`:
		Make.IfExp(
			test = Make.Compare(Make.Name('weather'), [ Make.Gt() ], [ Make.Constant(70) ]),
			body = Make.Constant("sunny"),
			orElse = Make.Constant("cloudy")
		)
		```

		"""
))

docstrings[identifierClass]['Import'] = Make.Expr(Make.Constant(
		f"""Make an `ast.Import` `object` representing a single `import` statement.

		The `ast.Import` `object` represents one `import` statement with zero or more module names separated by commas.
		Each module name is an `ast.alias` `object`. The series of module names is stored in `ast.Import.names` as a `list` of
		`ast.alias`.

		Nevertheless, with `Make.Import`, you must create exactly one `ast.alias` `object` to be placed in `ast.Import.names`.

		Parameters
		----------
		dotModule : identifierDotAttribute
			({diminutive2etymology['dotModule']}) The name of the module to import: the name may be in dot notation, also called attribute access; the name may be an absolute or relative import.
			This parameter corresponds with `ast.alias.name` in `ast.Import.names[0]`; or, written as one dot-notation statement, it corresponds with
			`ast.Import.names[0].name`.
		asName : str | None = None
			({diminutive2etymology['asName']}) The identifier of the module in the local scope: `asName` must be a valid identifier, so it cannot be in dot notation.
			This parameter corresponds with `ast.alias.asname` in `ast.Import.names[0]`; or, written as one dot-notation statement, it corresponds with
			`ast.Import.names[0].asname`.

		Returns
		-------
		importStatement : ast.Import
			An `ast.Import` `object` with one `ast.alias` `object` representing a single `import` statement with a single module name.

		Examples
		--------
		```python
		# To represent: `import os`
		Make.Import(dotModule = 'os')

		# To represent: `import re as regex`
		Make.Import(dotModule = 're', asName = 'regex')

		# To represent: `import collections.abc`
		Make.Import(dotModule = 'collections.abc')

		# To represent: `import scipy.signal.windows as SciPy`
		Make.Import(dotModule = 'scipy.signal.windows', asName = 'SciPy')
		```

		"""
))

docstrings[identifierClass]['ImportFrom'] = Make.Expr(Make.Constant(
		f"""Make a from-import statement AST `object` for selective module imports.

		(AI generated docstring)

		The `ast.ImportFrom` `object` represents `from ... import` statements that
		selectively import specific names from modules. It supports relative imports
		and multiple import aliases.

		Parameters
		----------
		module : str | None
			The source module name using dot notation, or None for relative
			imports that rely solely on the level parameter.
		names : Sequence[ast.alias]
			List of alias objects specifying which names to import and
			their optional aliases.
		level : int = 0
			({diminutive2etymology['level']}) Import level controlling relative vs absolute imports. Zero indicates
			absolute import, positive values indicate relative import depth.

		Returns
		-------
		fromImportStatement : ast.ImportFrom
			AST `object` representing a selective module import statement.

		"""
))

docstrings[identifierClass]['In'] = Make.Expr(Make.Constant(
		"""'In', meaning 'is ***In***cluded in' or 'has membership In', is the `object` representation of Python keyword '`in`'.

		`class` `ast.In` is a subclass of `ast.cmpop`, '***c***o***mp***arison ***op***erator', and
		only used in `class` `ast.Compare`, parameter '`ops`', ***op***erator***s***. The Python interpreter
		declares *This* `object` 'is ***In***cluded in' *That* `iterable` if *This* `object` matches a part of *That* `iterable`.

		Returns
		-------
		membershipOperator:
			AST `object` representing the keyword '`in`' membership test operator for use
			in `ast.Compare`.

		"""
))

docstrings[identifierClass]['Interactive'] = Make.Expr(Make.Constant(
		f"""Create an `ast.Interactive` ({diminutive2etymology['Interactive']}) node for interactive mode modules.

		(AI generated docstring)

		The `Interactive` node represents a module intended for interactive
		execution, such as in the Python REPL. Unlike regular modules, interactive
		modules can contain multiple statements that are executed sequentially.

		Parameters
		----------
		body : Sequence[ast.stmt] = []
			List of statements forming the interactive module body

		Returns
		-------
		nodeInteractive : ast.Interactive
			The constructed interactive module node

		"""
))

docstrings[identifierClass]['Invert'] = Make.Expr(Make.Constant(
		"""Make a bitwise complement operator representing Python '`~`' operator.

		(AI generated docstring)

		Class `ast.Invert` is a subclass of `ast.unaryop` and represents the bitwise complement
		or inversion operator '`~`' in Python source code. This operator performs bitwise
		NOT operation, flipping all bits of its operand. Used within `ast.UnaryOp`
		as the `op` parameter.

		Returns
		-------
		bitwiseComplementOperator : ast.Invert
			AST `object` representing the '`~`' bitwise complement operator for use
			in `ast.UnaryOp`.

		"""
))

docstrings[identifierClass]['Is'] = Make.Expr(Make.Constant(
		"""'Is', meaning 'Is identical to', is the `object` representation of Python keyword '`is`'.

		`class` `ast.Is` is a subclass of `ast.cmpop`, '***c***o***mp***arison ***op***erator', and
		only used in `class` `ast.Compare`, parameter '`ops`', ***op***erator***s***.

		The Python interpreter declares *This* logical `object` 'Is identical to' *That* logical
		`object` if they use the same physical memory location. Therefore, modifying one `object`
		will necessarily modify the other `object`.

		What's the difference between equality and identity? - The work of Jane Austen 'is Equal to'
		the work of Franz Kafka. - The work of Mark Twain 'is Equal to' the work of Samuel Clemens.
		- And Mark Twain 'Is identical to' Samuel Clemens: because they are the same person.

		Returns
		-------
		identityOperator:
			AST `object` representing the '`is`' identity comparison operator for use in
			`ast.Compare`.

		Examples
		--------
		```python # Logically equivalent to: `... valueAttributes is None ...` comparisonNode =
		Make.Compare(
			left=Make.Name('valueAttributes'), ops=[Make.Is()], comparators=[Make.Constant(None)]
		)
		```

			In the first example, the two statements are logically equal but they cannot be
			identical.

		"""
))

docstrings[identifierClass]['IsNot'] = Make.Expr(Make.Constant(
		"""'IsNot', meaning 'Is Not identical to', is the `object` representation of Python keywords '`is not`'.

		`class` `ast.IsNot` is a subclass of `ast.cmpop`, '***c***o***mp***arison ***op***erator',
		and only used in `class` `ast.Compare`, parameter '`ops`', ***op***erator***s***.

		The Python interpreter declares *This* logical `object` 'Is Not identical to' *That* logical
		`object` if they do not use the same physical memory location.

		What's the difference between equality and identity? - The work of Jane Austen 'is Equal to'
		the work of Franz Kafka. - The work of Mark Twain 'is Equal to' the work of Samuel Clemens.
		- And Mark Twain 'Is identical to' Samuel Clemens: because they are the same person.

		Python programmers frequently use '`is not None`' because keyword `None` does not have a
		physical memory location, so `if chicken is not None`, `chicken` must have a physical memory
		location (and be in the current scope and blah blah blah...).

		Returns
		-------
		identityNegationOperator:
			AST `object` representing the '`is not`' identity comparison operator for use in
			`ast.Compare`.

		Examples
		--------
		```python # Logically equivalent to: `... chicken is not None ...` comparisonNode =
		Make.Compare(
			left=Make.Name('chicken'), ops=[Make.IsNot()], comparators=[Make.Constant(None)]
		)
		```

			In the first example, the two statements are logically equal but they cannot be
			identical.

		"""
))

docstrings[identifierClass]['JoinedStr'] = Make.Expr(Make.Constant(
		f"""Make a joined string AST `object` for f-string literal construction.

		(AI generated docstring)

		The `ast.JoinedStr` ({diminutive2etymology['JoinedStr']}) `object` represents f-string
		literals that combine constant text with interpolated expressions. It coordinates multiple
		string components and formatted values into a single string literal.

		Parameters
		----------
		values : list[ast.expr]
			Sequence of string components, including `ast.Constant` and `ast.FormattedValue` objects.

		Returns
		-------
		joinedString : ast.JoinedStr
			AST `object` representing an f-string literal with interpolated values.

		"""
))

docstrings[identifierClass]['keyword'] = Make.Expr(Make.Constant(
		"""Make a keyword argument AST object for named parameters in function calls.

		(AI generated docstring)

		The `ast.keyword` object represents keyword arguments passed to function calls
		or class constructors. Contains the parameter name and corresponding value
		expression, including support for **keywordArguments unpacking.

		Parameters
		----------
		Buffalo_buffalo_Buffalo_buffalo_buffalo_buffalo_Buffalo_buffalo : str | None
			Parameter name string; None for **keywordArguments unpacking. This corresponds to `ast.keyword.arg`.
		value : ast.expr
			Expression providing the argument value.

		Returns
		-------
		keywordArgument : ast.keyword
			AST object representing a named argument in function calls.

		Examples
		--------
		Creates AST equivalent to: temperature=350
		```python
		namedArgument = Make.keyword('temperature', Make.Constant(350))
		```

		Creates AST equivalent to: **settings (keyword arguments unpacking)
		```python
		unpackedArguments = Make.keyword(None, Make.Name('settings'))
		```

		"""
))

docstrings[identifierClass]['Lambda'] = Make.Expr(Make.Constant(
		f"""Make a lambda function AST `object` for anonymous function expressions.

		(AI generated docstring)

		The `ast.Lambda` ({diminutive2etymology['Lambda']}) `object` represents lambda expressions
		that define anonymous functions with a single expression body. Lambda functions are limited
		to expressions and cannot contain statements or multiple lines.

		Parameters
		----------
		argumentSpecification : ast.arguments
			The function arguments specification as `ast.arguments`.
		body : ast.expr
			Single expression that forms the lambda function body.

		Returns
		-------
		lambdaFunction : ast.Lambda
			AST `object` representing an anonymous lambda function expression.

		"""
))

docstrings[identifierClass]['List'] = Make.Expr(Make.Constant(
		"""Make a list literal AST `object` with ordered element collection.

		(AI generated docstring)

		The `ast.List` `object` represents list literals using square bracket notation. It creates
		ordered, mutable collections and supports various contexts like loading values, storing to
		variables, or deletion operations.

		Parameters
		----------
		listElements : Sequence[ast.expr] = []
			Sequence of expressions that become list elements.
		context : ast.expr_context = ast.Load()
			Expression context for how the list is used.

		Returns
		-------
		listLiteral : ast.List
			AST `object` representing a list literal with specified elements.

		"""
))

docstrings[identifierClass]['ListComp'] = Make.Expr(Make.Constant(
		f"""Make a list comprehension AST `object` for dynamic list construction.

		(AI generated docstring)

		The `ast.ListComp` ({diminutive2etymology['ListComp']}) `object` represents list
		comprehensions that create lists using iterator expressions. It provides concise syntax for
		filtering and transforming collections into new lists.

		Parameters
		----------
		element : ast.expr
			({diminutive2etymology['elt']}) Expression that generates each element of the resulting list.
		generators : list[ast.comprehension]
			Sequence of `ast.comprehension` objects defining iteration and filtering.

		Returns
		-------
		listComprehension : ast.ListComp
			AST `object` representing a list comprehension expression.

		"""
))

docstrings[identifierClass]['Load'] = Make.Expr(Make.Constant(
		"""Make a load context for reading expression values.

		(AI generated docstring)

		The `ast.Load` context indicates expressions are being read or evaluated
		to retrieve their values. This is the default context for most expressions
		like `bicycle.wheel` when accessing the wheel attribute value.

		Returns
		-------
		loadContext : ast.Load
			AST context object indicating value retrieval operations.

		"""
))

docstrings[identifierClass]['Lt'] = Make.Expr(Make.Constant(
		"""'Lt', meaning 'is Less than', is the `object` representation of Python comparison operator '`<`'.

		`class` `ast.Lt` is a subclass of `ast.cmpop`, '***c***o***mp***arison ***op***erator', and
		only used in `class` `ast.Compare`, parameter '`ops`', ***op***erator***s***.

		Returns
		-------
		lessThanOperator:
			AST `object` representing the '`<`' less-than comparison operator for use
			in `ast.Compare`.

		"""
))

docstrings[identifierClass]['LtE'] = Make.Expr(Make.Constant(
		"""'LtE', meaning 'is Less than or Equal to', is the `object` representation of Python comparison operator '`<=`'.

		`class` `ast.LtE` is a subclass of `ast.cmpop`, '***c***o***mp***arison ***op***erator', and
		only used in `class` `ast.Compare`, parameter '`ops`', ***op***erator***s***.

		Returns
		-------
		lessThanOrEqualOperator:
			AST `object` representing the '`<=`' less-than-or-equal comparison operator
			for use in `ast.Compare`.

		"""
))

docstrings[identifierClass]['Match'] = Make.Expr(Make.Constant(
		f"""Make a match statement AST object for pattern matching with multiple cases.

		(AI generated docstring)

		The `ast.Match` ({diminutive2etymology['Match']}) object represents match statements that perform pattern matching
		against a subject expression. Contains the value being matched and a list of
		case clauses with their patterns and corresponding actions.

		Parameters
		----------
		subject : ast.expr
			Expression being matched against the case patterns.
		cases : Sequence[ast.match_case] = []
			({diminutive2etymology['match_case']}) List of match_case objects defining pattern-action pairs.

		Returns
		-------
		matchStatement : ast.Match
			AST object representing a complete pattern matching statement.

		"""
))

docstrings[identifierClass]['match_case'] = Make.Expr(Make.Constant(
		f"""Make a match case clause AST object for individual cases in `match` statements.

		(AI generated docstring)

		The `ast.match_case` ({diminutive2etymology['match_case']}) object represents individual case clauses within match
		statements. Contains the pattern to match, optional guard condition, and
		statements to execute when the pattern matches successfully.

		Parameters
		----------
		pattern : ast.pattern
			Pattern expression defining what values match this case.
		guard : ast.expr | None = None
			Optional conditional expression for additional filtering.
		body : Sequence[ast.stmt] = []
			List of statements to execute when pattern matches.

		Returns
		-------
		matchCase : ast.match_case
			AST object representing a single case clause in match statements.

		"""
))

docstrings[identifierClass]['MatchAs'] = Make.Expr(Make.Constant(
		f"""Create an `ast.MatchAs` ({diminutive2etymology['MatchAs']}) node representing a capture pattern or wildcard.

		(AI generated docstring)

		The `ast.MatchAs` node represents match patterns that capture values or serve as wildcards.
		This includes bare name patterns like `bicycle` that capture the matched value, "as"
		patterns like `Point(x, y) as location` that match a pattern and capture the result, and the
		wildcard pattern `_`.

		Parameters
		----------
		pattern : ast.pattern | None
			Optional pattern to match against. When `None`, creates a capture pattern (bare name) if
			`name` is provided, or wildcard if both are `None`.
		name : str | None
			Optional identifier to bind the matched value. When `None` and pattern is also `None`, creates the wildcard pattern.

		Returns
		-------
		matchAsNode : ast.MatchAs
			An `ast.MatchAs` node with the specified pattern and name.

		"""
))

docstrings[identifierClass]['MatchClass'] = Make.Expr(Make.Constant(
		f"""Create an `ast.MatchClass` ({diminutive2etymology['MatchClass']}) node for matching class instances.

		(AI generated docstring)

		The `ast.MatchClass` node represents patterns that match instances of a specific class,
		checking both the class type and extracting values from the instance's attributes. This
		enables structural pattern matching against objects.

		Parameters
		----------
		cls : ast.expr
			({diminutive2etymology['cls']}) Expression identifying the class to match against.
		patterns : list[ast.pattern] = [ ]
			Sequence of pattern nodes for positional matching against class-defined attributes.
		kwd_attrs : list[str] = [ ]
			({diminutive2etymology['kwd_attrs']}) List of attribute names for keyword-style matching.
		kwd_patterns : list[ast.pattern] = [ ]
			({diminutive2etymology['kwd_patterns']}) Sequence of pattern nodes corresponding to the keyword attributes.

		Returns
		-------
		matchClassNode : ast.MatchClass
			An `ast.MatchClass` node configured for the specified class and patterns.

		"""
))

docstrings[identifierClass]['MatchMapping'] = Make.Expr(Make.Constant(
		f"""Create an `ast.MatchMapping` ({diminutive2etymology['MatchMapping']}) node for matching dictionary-like objects.

		(AI generated docstring)

		The `ast.MatchMapping` node represents patterns that match mapping objects like
		dictionaries, checking for specific keys and extracting their values. The pattern can also
		capture remaining unmapped keys.

		Parameters
		----------
		keys : list[ast.expr] = [ ]
			Sequence of expression nodes representing the keys to match.
		patterns : list[ast.pattern] = [ ]
			Sequence of pattern nodes corresponding to the values associated with each key.
		rest : str | None
			({diminutive2etymology['rest']}) Optional identifier to capture remaining mapping elements not otherwise matched.

		Returns
		-------
		matchMappingNode : ast.MatchMapping
			An `ast.MatchMapping` node for the specified key-value patterns and optional rest capture.

		"""
))

docstrings[identifierClass]['MatchOr'] = Make.Expr(Make.Constant(
		f"""Create an `ast.MatchOr` ({diminutive2etymology['MatchOr']}) node for alternative pattern matching.

		(AI generated docstring)

		The `ast.MatchOr` node represents or-patterns that match if any of the alternative
		subpatterns succeed. The pattern tries each alternative in sequence until one matches or all
		fail.

		Parameters
		----------
		patterns : list[ast.pattern] = [ ]
			Sequence of alternative pattern nodes. The match succeeds if any subpattern matches the subject.

		Returns
		-------
		matchOrNode : ast.MatchOr
			An `ast.MatchOr` node containing the alternative patterns.

		"""
))

docstrings[identifierClass]['MatchSequence'] = Make.Expr(Make.Constant(
		f"""Create an `ast.MatchSequence` ({diminutive2etymology['MatchSequence']}) node for matching sequences.

		(AI generated docstring)

		The `ast.MatchSequence` node represents patterns that match sequence objects like lists and
		tuples, checking both length and element patterns. Supports both fixed-length and
		variable-length sequence matching.

		Parameters
		----------
		patterns : list[ast.pattern] = [ ]
			Sequence of pattern nodes to match against sequence elements. If any pattern is
			`MatchStar`, enables variable-length matching; otherwise requires exact length match.

		Returns
		-------
		matchSequenceNode : ast.MatchSequence
			An `ast.MatchSequence` node for the specified element patterns.

		"""
))

docstrings[identifierClass]['MatchSingleton'] = Make.Expr(Make.Constant(
		f"""Create an `ast.MatchSingleton` ({diminutive2etymology['MatchSingleton']}) node for matching singleton values.

		(AI generated docstring)

		The `ast.MatchSingleton` node represents patterns that match singleton constants by identity
		rather than equality. This pattern succeeds only if the match subject is the exact same
		object as the specified constant.

		Parameters
		----------
		value : None | bool
			The singleton constant to match against. Must be `None`, `True`, or `False`. Matching
			uses identity comparison (`is`) rather than equality comparison (`==`).

		Returns
		-------
		matchSingletonNode : ast.MatchSingleton
			An `ast.MatchSingleton` node for the specified singleton value.

		"""
))

docstrings[identifierClass]['MatchStar'] = Make.Expr(Make.Constant(
		f"""Create an `ast.MatchStar` ({diminutive2etymology['MatchStar']}) node for capturing sequence remainder.

		(AI generated docstring)

		The `ast.MatchStar` node represents star patterns that capture remaining elements in
		variable-length sequence patterns. This enables flexible sequence matching where some
		elements are specifically matched and others are collected.

		Parameters
		----------
		name : str | None = None
			Optional identifier to bind the remaining sequence elements. When `None`, the remaining elements are matched but not
			captured.

		Returns
		-------
		matchStarNode : ast.MatchStar
			An `ast.MatchStar` node with the specified capture name.

		"""
))

docstrings[identifierClass]['MatchValue'] = Make.Expr(Make.Constant(
		f"""Create an `ast.MatchValue` ({diminutive2etymology['MatchValue']}) node for matching literal values.

		(AI generated docstring)

		The `ast.MatchValue` node represents patterns that match by equality comparison against a
		literal value or expression. The pattern succeeds if the match subject equals the evaluated
		value expression.

		Parameters
		----------
		value : ast.expr
			Expression node representing the value to match against. Typically a constant, name, or
			attribute access. The expression is evaluated and compared using equality (`==`).

		Returns
		-------
		matchValueNode : ast.MatchValue
			An `ast.MatchValue` node for the specified value expression.

		"""
))

docstrings[identifierClass]['mod'] = Make.Expr(Make.Constant(
		f"""Create an appropriate `ast.mod` ({diminutive2etymology['mod']}) node based on the body content.

		(AI generated docstring)

		The `mod` method creates the appropriate module type node based on the
		provided body. This is a convenience method that determines whether to
		create a `Module`, `Expression`, or `Interactive` node.

		Parameters
		----------
		body : list[ast.stmt] | ast.expr
			Either a list of statements or a single expression

		Returns
		-------
		nodeMod : ast.mod
			The constructed module node of appropriate type

		"""
))

docstrings[identifierClass]['Module'] = Make.Expr(Make.Constant(
		f"""Make a module AST object representing complete Python modules with statements and type ignores.

		(AI generated docstring)

		The `ast.Module` object represents entire Python modules as parsed from source
		files. Contains all top-level statements and tracks type ignore comments for
		static analysis tools and type checkers.

		Parameters
		----------
		body : Sequence[ast.stmt] = []
			List of statements forming the module content.
		type_ignores : Sequence[ast.TypeIgnore] = []
			({diminutive2etymology['type_ignores']}) List of TypeIgnore objects for `# type: ignore` comments.

		Returns
		-------
		moduleDefinition : ast.Module
			AST object representing a complete Python module structure.

		Examples
		--------
		Creates AST equivalent to: x = 42
		```python
		simpleModule = Make.Module([Make.Assign([Make.Name('x')], Make.Constant(42))])
		```

		Creates AST equivalent to module with function and assignment
		```python
		moduleWithFunction = Make.Module([
			Make.FunctionDef('calculate', body=[Make.Return(Make.Constant(100))]),
			Make.Assign([Make.Name('result')], Make.Call(Make.Name('calculate'), []))
		])
		```

		"""
))

docstrings[identifierClass]['Name'] = Make.Expr(Make.Constant(
		f"""Make a name AST `object` for variable and identifier references.

		(AI generated docstring)

		The `ast.Name` `object` represents identifiers like variable names, function names, and
		class names in Python code. The context parameter determines whether the name is being
		loaded, stored to, or deleted.

		Parameters
		----------
		id : str
			({diminutive2etymology['id']}) The identifier string representing the name.
		context : ast.expr_context = ast.Load()
			Expression context specifying how the name is used.

		Returns
		-------
		nameReference : ast.Name
			AST `object` representing an identifier reference with specified context.

		"""
))

docstrings[identifierClass]['NamedExpr'] = Make.Expr(Make.Constant(
		f"""Make a named expression AST `object` for assignment expressions (walrus operator).

		(AI generated docstring)

		The `ast.NamedExpr` ({diminutive2etymology['NamedExpr']}) `object` represents assignment
		expressions using the walrus operator `:=` introduced in Python 3.8. It allows assignment
		within expressions and is commonly used in comprehensions and conditional statements.

		Parameters
		----------
		target : ast.Name
			The `ast.Name` `object` representing the variable being assigned to.
		value : ast.expr
			The expression whose value is assigned to the target.

		Returns
		-------
		namedExpression : ast.NamedExpr
			AST `object` representing an assignment expression with the walrus operator.

		Examples
		--------
		```python
		# Creates AST equivalent to: `(inventory := len(warehouse)) > 10`
		inventoryCheck = Make.Compare(
			left=Make.NamedExpr(
				target=Make.Name('inventory', ast.Store()),
				value=Make.Call(Make.Name('len'), [Make.Name('warehouse')])
			),
			ops=[Make.Gt()],
			comparators=[Make.Constant(10)]
		)
		```

		"""
))

docstrings[identifierClass]['Nonlocal'] = Make.Expr(Make.Constant(
		"""Create an `ast.Nonlocal` node for nonlocal declarations.

		(AI generated docstring)

		The `Nonlocal` node represents a `nonlocal` statement that declares
		variables as referring to the nearest enclosing scope that is not global.
		This is used in nested functions to modify variables from outer scopes.

		Parameters
		----------
		names : Sequence[str]
			List of variable names to declare as nonlocal.

		Returns
		-------
		nodeNonlocal : ast.Nonlocal
			The constructed nonlocal declaration node.

		"""
))

docstrings[identifierClass]['Not'] = Make.Expr(Make.Constant(
		"""Make a logical negation operator representing Python keyword '`not`'.

		(AI generated docstring)

		Class `ast.Not` is a subclass of `ast.unaryop` and represents the logical negation
		operator keyword '`not`' in Python source code. This operator returns the boolean
		inverse of its operand's truthiness. Used within `ast.UnaryOp` as the
		`op` parameter.

		Returns
		-------
		logicalNegationOperator : ast.Not
			AST `object` representing the keyword '`not`' logical negation operator for use
			in `ast.UnaryOp`.

		"""
))

docstrings[identifierClass]['NotEq'] = Make.Expr(Make.Constant(
		"""'NotEq' meaning 'is ***Not*** ***Eq***ual to', is the `object` representation of Python comparison operator '`!=`'.

		`class` `ast.NotEq` is a subclass of `ast.cmpop`, '***c***o***mp***arison ***op***erator', and
		only used in `class` `ast.Compare`, parameter '`ops`', ***op***erator***s***.

		Returns
		-------
		inequalityOperator:
			AST `object` representing the '`!=`' inequality comparison operator for use
			in `ast.Compare`.

		"""
))

docstrings[identifierClass]['NotIn'] = Make.Expr(Make.Constant(
		"""'NotIn', meaning 'is Not ***In***cluded in' or 'does Not have membership In', is the `object` representation of Python keywords '`not in`'.

		`class` `ast.NotIn` is a subclass of `ast.cmpop`, '***c***o***mp***arison ***op***erator',
		and only used in `class` `ast.Compare`, parameter '`ops`', ***op***erator***s***. The Python
		interpreter declares *This* `object` 'is Not ***In***cluded in' *That* `iterable` if *This*
		`object` does not match a part of *That* `iterable`.

		Returns
		-------
		negativeMembershipOperator:
			AST `object` representing the keywords '`not in`' negative membership test operator
			for use in `ast.Compare`.

		"""
))

docstrings[identifierClass]['operator'] = Make.Expr(Make.Constant(
		"""Create an `ast.operator` node for arithmetic and bitwise operations.

		(AI generated docstring)

		The `operator` method creates operator nodes used in binary operations,
		unary operations, and comparison operations. These represent the specific
		operation to be performed.

		Returns
		-------
		nodeOperator: The constructed operator node

		"""
))

docstrings[identifierClass]['ParamSpec'] = Make.Expr(Make.Constant(
			f"""Make a parameter specification type parameter for generic callable types.

			(AI generated docstring)

			The `ast.ParamSpec` ({diminutive2etymology['ParamSpec']}) object represents parameter
			specification type parameters used in generic callable types. Captures both positional and
			keyword argument signatures for type-safe function composition and higher-order functions.

			Parameters
			----------
			name : str
				Type parameter name as string identifier.
			default_value : ast.expr | None = None
				Optional default type expression (Python 3.13+).

			Returns
			-------
			parameterSpecification : ast.ParamSpec
				AST object representing a parameter specification type parameter.

			"""
))

docstrings[identifierClass]['Pass'] = Make.Expr(Make.Constant(
		"""Create an `ast.Pass` node for pass statements.

		(AI generated docstring)

		The `Pass` node represents a `pass` statement, which is a null operation
		that does nothing when executed. It serves as syntactic placeholder where
		a statement is required but no action is needed.

		Returns
		-------
		nodePass : ast.Pass
			The constructed pass statement node.

		"""
))

docstrings[identifierClass]['pattern'] = Make.Expr(Make.Constant(
		"""Create a base `ast.pattern` node.

		(AI generated docstring)

		Creates a generic `ast.pattern` node that serves as the abstract base for all pattern types
		in match statements. This method is typically used for creating pattern node instances
		programmatically when the specific pattern type is determined at runtime.

		Returns
		-------
		patternNode : ast.pattern
			A base `ast.pattern` node with the specified attributes.

		"""
))

docstrings[identifierClass]['Raise'] = Make.Expr(Make.Constant(
		f"""Create an `ast.Raise` node for raise statements.

		(AI generated docstring)

		The `Raise` node represents a `raise` statement that raises an exception.
		Can re-raise the current exception, raise a new exception, or raise with
		an explicit cause chain.

		Parameters
		----------
		exc : ast.expr | None = None
			({diminutive2etymology['exc']}) Optional expression for the exception to raise.
		cause : ast.expr | None = None
			Optional expression for the exception cause.

		Returns
		-------
		nodeRaise : ast.Raise
			The constructed raise statement node.

		"""
))

docstrings[identifierClass]['Return'] = Make.Expr(Make.Constant(
		"""Make a return statement AST object for function value returns and early exits.

		(AI generated docstring)

		The `ast.Return` object represents return statements that exit functions and
		optionally provide return values. Used for both value-returning functions
		and procedures that return None implicitly or explicitly.

		Parameters
		----------
		value : ast.expr | None = None
			Optional expression providing the return value; None for empty return.

		Returns
		-------
		returnStatement : ast.Return
			AST object representing a function return with optional value.

		"""
))

docstrings[identifierClass]['Set'] = Make.Expr(Make.Constant(
		"""Make a set literal AST `object` for unordered unique element collections.

		(AI generated docstring)

		The `ast.Set` `object` represents set literals using curly brace notation. It creates
		unordered collections of unique elements with efficient membership testing and set
		operations.

		Parameters
		----------
		listElements : Sequence[ast.expr] = []
			Sequence of expressions that become set elements.

		Returns
		-------
		setLiteral : ast.Set
			AST `object` representing a set literal with specified unique elements.

		"""
))

docstrings[identifierClass]['SetComp'] = Make.Expr(Make.Constant(
		f"""Make a set comprehension AST `object` for dynamic set construction.

		(AI generated docstring)

		The `ast.SetComp` ({diminutive2etymology['SetComp']}) `object` represents set comprehensions
		that create sets using iterator expressions. It automatically handles uniqueness while
		providing concise syntax for filtering and transforming collections.

		Parameters
		----------
		element : ast.expr
			Expression that generates each element of the resulting set.
		generators : list[ast.comprehension]
			Sequence of `ast.comprehension` objects defining iteration and filtering.

		Returns
		-------
		setComprehension : ast.SetComp
			AST `object` representing a set comprehension expression.

		"""
))

docstrings[identifierClass]['Slice'] = Make.Expr(Make.Constant(
		f"""Make a slice AST `object` for sequence slicing operations.

		(AI generated docstring)

		The `ast.Slice` `object` represents slice expressions used with subscription operations to
		extract subsequences from collections. It supports the full Python slicing syntax with
		optional start, stop, and step parameters.

		Parameters
		----------
		lower : ast.expr | None = None
			({diminutive2etymology['lower']}) Optional expression for slice start position.
		upper : ast.expr | None = None
			({diminutive2etymology['upper']}) Optional expression for slice end position.
		step : ast.expr | None = None
			Optional expression for slice step size.

		Returns
		-------
		sliceExpression : ast.Slice
			AST `object` representing a slice operation for sequence subscripting.

		"""
))

docstrings[identifierClass]['Starred'] = Make.Expr(Make.Constant(
		"""Make a starred expression AST `object` for unpacking operations.

		(AI generated docstring)

		The `ast.Starred` `object` represents starred expressions using the `*` operator for
		unpacking iterables in various contexts like function calls, assignments, and collection
		literals.

		Parameters
		----------
		value : ast.expr
			The expression to be unpacked with the star operator.
		context : ast.expr_context = ast.Load()
			Expression context determining how the starred expression is used.

		Returns
		-------
		starredExpression : ast.Starred
			AST `object` representing a starred expression for unpacking operations.

		Examples
		--------
		```python
		# Creates AST equivalent to: `*ingredients` in function call
		unpackIngredients = Make.Starred(Make.Name('ingredients'))

		# Creates AST equivalent to: `*remaining` in assignment like `first, *remaining = groceries`
		unpackRemaining = Make.Starred(Make.Name('remaining'), ast.Store())
		```

		"""
))

docstrings[identifierClass]['stmt'] = Make.Expr(Make.Constant(
		f"""`class` `ast.stmt` ({diminutive2etymology['stmt']}) is the base class for all statement nodes.

		Parameters
		----------
		**keywordArguments : ast_attributes
			Positional attributes.

		Returns
		-------
		nodeStmt : ast.stmt
			The constructed statement node.

		"""
))

docstrings[identifierClass]['Store'] = Make.Expr(Make.Constant(
		"""Make a store context for assigning values to expressions.

		(AI generated docstring)

		The `ast.Store` context indicates expressions are assignment targets
		receiving new values. Used in assignments, loop targets, and function
		parameters where expressions store rather than load values.

		Returns
		-------
		storeContext : ast.Store
			AST context object indicating value assignment operations.

		Examples
		--------
		Creates AST equivalent to assignment: bicycle.wheel = newWheel
		```python
		wheelAssignment = Make.Attribute(Make.Name('bicycle'), 'wheel', Make.Store())
		```

		"""
))

docstrings[identifierClass]['Subscript'] = Make.Expr(Make.Constant(
		"""Make a subscript AST `object` for indexing and slicing operations.

		(AI generated docstring)

		The `ast.Subscript` `object` represents subscription operations using square brackets for
		indexing, slicing, and key access in dictionaries and other subscriptable objects.

		Parameters
		----------
		value : ast.expr
			The expression being subscripted (e.g., list, dict, string).
		slice : ast.expr
			The subscript expression, which can be an index, slice, or key.
		context : ast.expr_context = ast.Load()
			Expression context for how the subscript is used.

		Returns
		-------
		subscriptExpression : ast.Subscript
			AST `object` representing a subscription operation with brackets.

		"""
))

docstrings[identifierClass]['Try'] = Make.Expr(Make.Constant(
		f"""Make a try-except statement AST `object` for exception handling and resource cleanup.

		(AI generated docstring)

		The `ast.Try` `object` represents `try-except` statements that handle exceptions
		and provide cleanup mechanisms. It supports multiple exception handlers, optional
		else clauses, and finally blocks for guaranteed cleanup.

		Parameters
		----------
		body : Sequence[ast.stmt]
			Sequence of statements in the try block that may raise exceptions.
		handlers : Sequence[ast.ExceptHandler]
			List of exception handler objects that catch and process specific
			exception types or patterns.
		orelse : Sequence[ast.stmt] = []
			({diminutive2etymology['orElse']}) Optional statements executed when the try block completes without
			raising exceptions.
		finalbody : Sequence[ast.stmt] = []
			({diminutive2etymology['finalbody']}) Optional statements always executed for cleanup, regardless
			of whether exceptions occurred.

		Returns
		-------
		tryStatement : ast.Try
			AST `object` representing an exception handling statement with optional cleanup.

		"""
))

docstrings[identifierClass]['TryStar'] = Make.Expr(Make.Constant(
		f"""Make a try-except* statement AST `object` for exception group handling.

		(AI generated docstring)

		The `ast.TryStar` ({diminutive2etymology['TryStar']}) `object` represents `try-except*` statements introduced in
		Python 3.11 for handling exception groups. It enables catching and processing
		multiple related exceptions that occur simultaneously.

		Parameters
		----------
		body : Sequence[ast.stmt]
			Sequence of statements in the try block that may raise exception groups.
		handlers : Sequence[ast.ExceptHandler]
			List of exception handler objects that catch and process specific
			exception types within exception groups.
		orelse : Sequence[ast.stmt] = []
			({diminutive2etymology['orElse']}) Optional statements executed when the try block completes without
			raising exceptions.
		finalbody : Sequence[ast.stmt] = []
			({diminutive2etymology['finalbody']}) Optional statements always executed for cleanup, regardless
			of whether exception groups occurred.

		Returns
		-------
		tryStarStatement : ast.TryStar
			AST `object` representing an exception group handling statement with optional cleanup.

		"""
))

docstrings[identifierClass]['Tuple'] = Make.Expr(Make.Constant(
		"""Make a tuple literal AST `object` for ordered immutable collections.

		(AI generated docstring)

		The `ast.Tuple` `object` represents tuple literals using parentheses or comma separation.
		Tuples are immutable, ordered collections often used for multiple assignments and function
		return values.

		Parameters
		----------
		listElements : Sequence[ast.expr] = []
			Sequence of expressions that become tuple elements.
		context : ast.expr_context = ast.Load()
			Expression context for how the tuple is used.

		Returns
		-------
		tupleLiteral : ast.Tuple
			AST `object` representing a tuple literal with specified elements.

		"""
))

docstrings[identifierClass]['type_ignore'] = Make.Expr(Make.Constant(
		f"""`class` `ast.type_ignore` ({diminutive2etymology['type_ignore']}) is the base class for `ast.TypeIgnore`."""
))

docstrings[identifierClass]['type_param'] = Make.Expr(Make.Constant(
		f"""Abstract type parameter base for generic type constructs.

		(AI generated docstring)

		The `ast.type_param` ({diminutive2etymology['type_param']}) object serves as the abstract base for type parameters
		including TypeVar, ParamSpec, and TypeVarTuple. Provides common functionality
		for generic type definitions in classes, functions, and type aliases.

		Returns
		-------
		typeParameter : ast.type_param
			Abstract AST object representing the base of type parameter hierarchy.

		"""
))

docstrings[identifierClass]['TypeAlias'] = Make.Expr(Make.Constant(
		f"""Make a type alias definition AST object for `type` statement declarations.

		(AI generated docstring)

		The `ast.TypeAlias` ({diminutive2etymology['TypeAlias']}) object represents type alias
		definitions using the `type` statement syntax. Associates a name with a type expression,
		supporting generic type parameters for flexible type definitions.

		Parameters
		----------
		name : ast.expr
			Name expression (typically ast.Name) for the alias identifier.
		type_params : Sequence[ast.type_param]
			({diminutive2etymology['type_params']}) List of type parameters for generic aliases.
		value : ast.expr
			Type expression defining what the alias represents.

		Returns
		-------
		typeAliasDefinition : ast.TypeAlias
			AST object representing a complete type alias declaration.

		"""
))

docstrings[identifierClass]['TypeIgnore'] = Make.Expr(Make.Constant(
		f"""Make a type ignore comment AST object for `# type: ignore` directives.

		(AI generated docstring)

		The `ast.TypeIgnore` ({diminutive2etymology['TypeIgnore']}) object represents `# type: ignore` comments that
		instruct static type checkers to skip type analysis for specific lines.
		Includes optional tags for categorizing different types of ignores.

		Parameters
		----------
		lineno : int
			({diminutive2etymology['lineno']}) Line number where the ignore comment appears.
		tag : str = ''
			Optional string tag for categorizing the ignore (e.g., '[assignment]').

		Returns
		-------
		typeIgnoreDirective : ast.TypeIgnore
			AST object representing a type checker ignore comment.

		Examples
		--------
		Creates AST equivalent to: # type: ignore (on line 42)
		```python
		simpleIgnore = Make.TypeIgnore(42, '')
		```

		Creates AST equivalent to: # type: ignore[assignment] (on line 15)
		```python
		taggedIgnore = Make.TypeIgnore(15, '[assignment]')
		```

		"""
))

docstrings[identifierClass]['TypeVar'] = Make.Expr(Make.Constant(
			f"""Make a type variable parameter for generic types with optional bounds and defaults.

			(AI generated docstring)

			The `ast.TypeVar` ({diminutive2etymology['TypeVar']}) object represents type variable parameters used in generic
			classes, functions, and type aliases. Supports type bounds, constraints,
			and default values for flexible generic programming.

			Parameters
			----------
			name : str
				Type variable name as string identifier.
			bound : ast.expr | None = None
				Optional type expression constraining allowed types.
			default_value : ast.expr | None = None
				Optional default type expression (Python 3.13+).

			Returns
			-------
			typeVariable : ast.TypeVar
				AST object representing a type variable with optional constraints.

			"""
))

docstrings[identifierClass]['TypeVarTuple'] = Make.Expr(Make.Constant(
			f"""Make a type variable tuple for variadic generic types.

			(AI generated docstring)

			The `ast.TypeVarTuple` ({diminutive2etymology['TypeVarTuple']}) object represents type variable tuples used for
			variadic generic types that accept variable numbers of type arguments.
			Enables generic types that work with arbitrary-length type sequences.

			Parameters
			----------
			name : str
				Type variable tuple name as string identifier.
			default_value : ast.expr | None = None
				Optional default type tuple expression (Python 3.13+).

			Returns
			-------
			typeVariableTuple : ast.TypeVarTuple
				AST object representing a variadic type variable.

			"""
))

docstrings[identifierClass]['UAdd'] = Make.Expr(Make.Constant(
		f"""Unary addition operator representing Python '`+`' operator.

		(AI generated docstring)

		Class `ast.UAdd` ({diminutive2etymology['UAdd']}) is a subclass of `ast.unaryop` and represents the unary positive
		operator '`+`' in Python source code. This operator explicitly indicates
		a positive numeric value. Used within `ast.UnaryOp` as the `op` parameter.

		Returns
		-------
		unaryPositiveOperator : ast.UAdd
			AST `object` representing the '`+`' unary positive operator for use
			in `ast.UnaryOp`.

		"""
))

docstrings[identifierClass]['unaryop'] = Make.Expr(Make.Constant(
		f"""Abstract unary operator `object` for use in AST construction.

		(AI generated docstring)

		Class `ast.unaryop` ({diminutive2etymology['unaryop']}) is the base for all unary operators in Python's AST.
		It serves as the abstract parent for specific unary operators: `ast.Invert`,
		`ast.Not`, `ast.UAdd`, `ast.USub`. This factory method makes a generic
		unary operator `object` that can be used in the antecedent-action pattern with visitor classes.

		Unlike `ast.cmpop` which handles binary comparison operations between two operands,
		`ast.unaryop` represents operators that act on a single operand. Both serve as abstract
		base classes but for different categories of operations: `ast.cmpop` for comparisons
		and `ast.unaryop` for unary transformations.

		Returns
		-------
		unaryOperator : ast.unaryop
			Abstract unary operator `object` that serves as the base `class` for all
			Python unary operators in AST structures.

		"""
))

docstrings[identifierClass]['UnaryOp'] = Make.Expr(Make.Constant(
		f"""Unary operation AST `object` for single-operand operations.

		(AI generated docstring)

		The `ast.UnaryOp` ({diminutive2etymology['UnaryOp']}) `object` represents unary operations
		that take a single operand, such as negation, logical not, bitwise inversion, and positive
		sign operations.

		Parameters
		----------
		op : ast.unaryop
			({diminutive2etymology['op']}) The unary operator like `ast.UAdd()`, `ast.USub()`, `ast.Not()`, `ast.Invert()`.
		operand : ast.expr
			The expression that the unary operator is applied to.

		Returns
		-------
		unaryOperation : ast.UnaryOp
			({diminutive2etymology['UnaryOp']}) AST `object` representing a unary operation on a single expression.

		"""
))

docstrings[identifierClass]['USub'] = Make.Expr(Make.Constant(
		f"""Unary subtraction operator representing Python '`-`' operator.

		(AI generated docstring)

		Class `ast.USub` ({diminutive2etymology['USub']}) is a subclass of `ast.unaryop` and
		represents the unary negation operator '`-`' in Python source code. This operator makes the
		arithmetic negative of its operand. Used within `ast.UnaryOp` as the `op` parameter.

		Returns
		-------
		unaryNegativeOperator : ast.USub
			AST `object` representing the '`-`' unary negation operator for use
			in `ast.UnaryOp`.

		"""
))

docstrings[identifierClass]['While'] = Make.Expr(Make.Constant(
		f"""Make a while loop AST `object` for condition-based iteration.

		(AI generated docstring)

		The `ast.While` `object` represents `while` loops that repeatedly execute
		a block of statements as long as a test condition remains True. It supports
		optional else clauses that execute when the loop exits normally.

		Parameters
		----------
		test : ast.expr
			The boolean expression evaluated before each iteration to determine
			whether the loop should continue executing.
		body : Sequence[ast.stmt]
			Sequence of statements executed repeatedly while the test condition is True.
		orelse : Sequence[ast.stmt] = []
			({diminutive2etymology['orElse']}) Optional statements executed when the loop exits normally
			without encountering a break statement.

		Returns
		-------
		whileLoop : ast.While
			AST `object` representing a condition-based iteration statement.

		"""
))

docstrings[identifierClass]['With'] = Make.Expr(Make.Constant(
		"""Make a context manager statement AST `object` for resource management and cleanup.

		(AI generated docstring)

		The `ast.With` `object` represents `with` statements that manage resources
		using context managers. These ensure proper setup and cleanup of resources
		like files, database connections, or locks.

		Parameters
		----------
		items : Sequence[ast.withitem]
			Sequence of context manager items, each specifying a context manager
			expression and optional variable binding for the managed resource.
		body : Sequence[ast.stmt]
			Sequence of statements executed within the context manager scope.

		Returns
		-------
		withStatement : ast.With
			AST `object` representing a context manager statement for resource management.

		"""
))

docstrings[identifierClass]['withitem'] = Make.Expr(Make.Constant(
		f"""Make a context manager item AST object for individual items in `with` statements.

		(AI generated docstring)

		The `ast.withitem` ({diminutive2etymology['withitem']}) object represents individual context
		manager specifications within `with` statements. Contains the context expression and
		optional variable binding for the context manager's return value.

		Parameters
		----------
		context_expr : ast.expr
			({diminutive2etymology['context_expr']}) Expression providing the context manager object.
		optional_vars : ast.expr | None = None
			({diminutive2etymology['optional_vars']}) Optional variable expression for `as` binding.

		Returns
		-------
		contextItem : ast.withitem
			AST object representing a single context manager in with statements.

		"""
))

docstrings[identifierClass]['Yield'] = Make.Expr(Make.Constant(
		f"""Make a yield expression AST `object` for generator function values.

		(AI generated docstring)

		The `ast.Yield` ({diminutive2etymology['Yield']}) `object` represents yield expressions that
		produce values in generator functions. It suspends function execution and yields a value to
		the caller, allowing resumption from the same point.

		Parameters
		----------
		value : ast.expr | None = None
			Optional expression to yield; None yields None value.

		Returns
		-------
		yieldExpression : ast.Yield
			({diminutive2etymology['Yield']}) AST `object` representing a yield expression for generator functions.

		"""
))

docstrings[identifierClass]['YieldFrom'] = Make.Expr(Make.Constant(
		f"""Make a yield from expression AST `object` for delegating to sub-generators.

		(AI generated docstring)

		The `ast.YieldFrom` ({diminutive2etymology['YieldFrom']}) `object` represents `yield from`
		expressions that delegate generator execution to another iterable or generator. It provides
		efficient sub-generator delegation introduced in Python 3.3.

		Parameters
		----------
		value : ast.expr
			The iterable or generator expression to delegate to.

		Returns
		-------
		yieldFromExpression : ast.YieldFrom
			({diminutive2etymology['YieldFrom']}) AST `object` representing a yield from expression for generator delegation.

		"""
))

